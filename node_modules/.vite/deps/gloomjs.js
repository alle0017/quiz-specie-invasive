var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/gloomjs/core/reactivity/list.js
var createNode = (value) => {
  return {
    prev: null,
    next: null,
    value
  };
};
var append = (list, value) => {
  const node = createNode(value);
  if (!list.head) {
    list.head = node;
  } else {
    list.head.prev = node;
    node.next = list.head;
    list.head = node;
  }
};
var remove = (list, node) => {
  if (!node.prev) {
    list.head = node.next;
  } else {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  return node.value;
};

// node_modules/gloomjs/core/reactivity/signal.js
var _subs, _value, _Signal_instances, notifyAll_fn;
var Signal = class {
  /**
   * 
   * @param {T} value 
   */
  constructor(value) {
    __privateAdd(this, _Signal_instances);
    /**
     * @type {ListRoot<Subscriber>}
     */
    __privateAdd(this, _subs, {
      head: null
    });
    /**
     * @type {T}
     */
    __privateAdd(this, _value);
    __privateSet(this, _value, value);
  }
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    if (value == __privateGet(this, _value) && typeof value !== "object")
      return;
    if (typeguard_default.Component(__privateGet(this, _value))) {
      if (typeguard_default.Component(value) && __privateGet(this, _value).isEqualTo(value)) {
        __privateGet(this, _value).update(...value.args);
      } else {
        __privateGet(this, _value).dispose();
        __privateSet(this, _value, value);
      }
    } else if (typeguard_default.ComponentList(__privateGet(this, _value))) {
      if (typeguard_default.ComponentList(value)) {
        const minLen = __privateGet(this, _value).length > value.length ? value.length : __privateGet(this, _value).length;
        for (let i = 0; i < minLen; i++) {
          if (__privateGet(this, _value)[i].isEqualTo(value[i])) {
            __privateGet(this, _value)[i].update(...value[i].args);
          } else {
            __privateGet(this, _value)[i].dispose();
            __privateGet(this, _value)[i] = value[i];
          }
        }
        if (minLen == value.length) {
          for (let i = minLen; i < __privateGet(this, _value).length; i++) {
            __privateGet(this, _value)[i].dispose();
          }
          __privateGet(this, _value).splice(minLen, __privateGet(this, _value).length - minLen);
        } else {
          __privateGet(this, _value).push(...value.slice(minLen));
        }
      } else {
        for (let i = 0; i < __privateGet(this, _value).length; i++) {
          __privateGet(this, _value)[i].dispose();
        }
        __privateSet(this, _value, value);
      }
    } else {
      __privateSet(this, _value, value);
    }
    __privateMethod(this, _Signal_instances, notifyAll_fn).call(this);
  }
  /**
   * return the function used to unsubscribe the subscription
   * @param {ReactiveRef} ref 
   */
  subscribe(ref) {
    if (ref.isComponent) {
      const desc = (
        /**@type {ComponentRef} */
        ref
      );
      append(
        __privateGet(this, _subs),
        {
          update: () => {
            if (typeguard_default.ComponentList(__privateGet(this, _value))) {
              const tree = [];
              for (let i = 0; i < __privateGet(this, _value).length; i++) {
                tree.push(...__privateGet(this, _value)[i].render({ args: [], tree: [], refToArgs: [], idx: 0 }));
              }
              desc.root.after(...tree);
            } else if (typeguard_default.Component(__privateGet(this, _value))) {
              desc.root.after(
                ...__privateGet(this, _value).render({ args: [], tree: [], refToArgs: [], idx: 0 })
              );
            }
          }
        }
      );
    } else {
      const desc = (
        /**@type {SimpleRef}*/
        ref
      );
      append(
        __privateGet(this, _subs),
        {
          update: () => {
            if (desc.isTextNode) {
              desc.root.textContent = /**@type {string}*/
              __privateGet(this, _value);
            } else if (desc.attributeValue) {
              desc.root.setAttribute(
                desc.attribute,
                /**@type {string}*/
                __privateGet(this, _value)
              );
            } else {
              const node = document.createElement(
                /**@type {string}*/
                __privateGet(this, _value)
              );
              desc.root.replaceWith(node);
              desc.root = node;
            }
          }
        }
      );
    }
    const ticket = __privateGet(this, _subs).head;
    return () => remove(__privateGet(this, _subs), ticket);
  }
  /**
   * return the function used to unsubscribe the subscription
   * @param {Subscriber} effect
   */
  subscribeEffect(effect) {
    append(
      __privateGet(this, _subs),
      effect
    );
    const ticket = __privateGet(this, _subs).head;
    return () => remove(__privateGet(this, _subs), ticket);
  }
  /**
   * create an Effect that returns:
   * - the value returned by the callback invoked on the state of the signal if the signal value is not an array
   * - a list of values, returned by calling the callback on each element of the state, if the state is an array
   * the same effect can be achieved by using an effect in combination with the map function
   * @example
   * ```javascript
   * const list = $signal([]);
   * list.map( 
   *     (v,i) => TodoItem({ description: v, onDelete: () => onDelete(i) }) 
   * )
   * // is equal to
   * const renderedList = $effect(
   *    () => list.value.map((v,i) => TodoItem({ description: v, onDelete: () => onDelete(i) }) ),
   *    list
   * )
   * ```
   * @template V
   * @param {T extends Array<infer K> ? (v: K, index: number) => V : (v: T) => V } callback 
   */
  map(callback) {
    return new Effect(
      () => {
        if (__privateGet(this, _value) instanceof Array) {
          const res = [];
          for (let i = 0; i < __privateGet(this, _value).length; i++) {
            res.push(callback(__privateGet(this, _value)[i], i));
          }
          return res;
        } else {
          return callback(__privateGet(this, _value));
        }
      },
      this
    );
  }
};
_subs = new WeakMap();
_value = new WeakMap();
_Signal_instances = new WeakSet();
notifyAll_fn = function() {
  let curr = __privateGet(this, _subs).head;
  while (curr) {
    curr.value.update();
    curr = curr.next;
  }
};

// node_modules/gloomjs/core/template/component-parser.js
var _pointerToReactive, _tagRegex, _tagAttrRegex, _tagNameRegex, _closingTagRegex, _selfClosingTagRegex, _ComponentParser_static, parsePossibleTag_fn, compareWithReactivePointer_fn;
var _ComponentParser = class _ComponentParser {
  static get pointerToReactive() {
    return __privateGet(this, _pointerToReactive);
  }
  /**
   * @throws {ReferenceError} if the pointer keyword is used inside the template
   * @throws {DOMException} if the parsing phase notice an error. some scenarios are when a tag is closed but is never opened
   * @param {Readonly<string>} template
   * @returns {Tree[]}
   */
  static createHtmlTree(template) {
    const root = {
      tagName: null,
      attributes: null,
      children: [],
      reference: null,
      isTextNode: false,
      numOfInterpolations: 0
    };
    const stack = [root];
    let text = "";
    for (let i = 0; i < template.length; i++) {
      if (template[i] == __privateGet(_ComponentParser, _pointerToReactive)[0] && __privateMethod(this, _ComponentParser_static, compareWithReactivePointer_fn).call(this, template.slice(i))) {
        stack.at(-1).children.push(
          // the text found before
          {
            children: [],
            isTextNode: true,
            tagName: text,
            reference: void 0,
            attributes: [],
            numOfInterpolations: 0
          },
          // the reactive node
          {
            children: [],
            isTextNode: true,
            tagName: __privateGet(_ComponentParser, _pointerToReactive),
            reference: void 0,
            attributes: [],
            numOfInterpolations: 1
          }
        );
        stack.at(-1).numOfInterpolations++;
        text = "";
        i += __privateGet(_ComponentParser, _pointerToReactive).length - 1;
        continue;
      }
      if (template[i] == "\\") {
        text += "\\" + template[i + 1];
        i++;
        continue;
      }
      if (template[i] == "<") {
        const last = template.indexOf(">", i + 1);
        if (last >= 0) {
          const tag = template.slice(i, last + 1);
          if (tag.match(__privateGet(_ComponentParser, _closingTagRegex))) {
            stack.at(-1).children.push({
              children: [],
              isTextNode: true,
              tagName: text,
              reference: void 0,
              attributes: [],
              numOfInterpolations: 0
            });
            text = "";
            const tree = stack.pop();
            stack.at(-1).numOfInterpolations += tree.numOfInterpolations;
            if (stack.length < 1)
              throw new DOMException("Invalid closing tag in template");
            i = last;
            continue;
          }
          const res = __privateMethod(this, _ComponentParser_static, parsePossibleTag_fn).call(this, tag);
          if (!res.isTag) {
            text += template[i];
            continue;
          }
          stack.at(-1).children.push({
            children: [],
            isTextNode: true,
            tagName: text,
            reference: void 0,
            attributes: [],
            numOfInterpolations: 0
          }, res.tree);
          if (!tag.match(__privateGet(_ComponentParser, _selfClosingTagRegex))) {
            stack.push(res.tree);
          } else {
            stack.at(-1).numOfInterpolations += res.tree.numOfInterpolations;
          }
          text = "";
          i = last;
          continue;
        }
      }
      text += template[i];
    }
    root.children.push({
      children: [],
      isTextNode: true,
      tagName: text,
      reference: void 0,
      attributes: [],
      numOfInterpolations: 0
    });
    return root.children;
  }
  /**
   * @param {TemplateStringsArray} strings 
   * @returns {string}
   */
  static reduceTemplateStringArray(strings) {
    return strings.reduce((p, c) => {
      if (c.indexOf(__privateGet(_ComponentParser, _pointerToReactive)) >= 0) {
        throw new ReferenceError(
          __privateGet(_ComponentParser, _pointerToReactive) + " is a private keyword. consider using other words instead or escaping it with codes."
        );
      }
      return p + __privateGet(_ComponentParser, _pointerToReactive) + c;
    });
  }
};
_pointerToReactive = new WeakMap();
_tagRegex = new WeakMap();
_tagAttrRegex = new WeakMap();
_tagNameRegex = new WeakMap();
_closingTagRegex = new WeakMap();
_selfClosingTagRegex = new WeakMap();
_ComponentParser_static = new WeakSet();
parsePossibleTag_fn = function(slice) {
  const check = slice.match(__privateGet(_ComponentParser, _tagRegex));
  if (!check || check.index !== 0) {
    return {
      isTag: false,
      tree: null
    };
  }
  const attributes = [];
  const tagName = slice.match(__privateGet(_ComponentParser, _tagNameRegex))[0].replace("<", "");
  const attribNameAndVal = slice.replace(new RegExp(`(${tagName})`), "").match(__privateGet(_ComponentParser, _tagAttrRegex)) || [];
  let numOfInterpolations = 0;
  if (tagName == __privateGet(_ComponentParser, _pointerToReactive)) {
    numOfInterpolations++;
  }
  for (let i = 0; i < attribNameAndVal.length; i++) {
    let [name, value] = attribNameAndVal[i].split("=");
    if (value && (value[0] == "'" || value[0] == '"')) {
      value = value.slice(1, value.length - 1);
    }
    if (name == __privateGet(_ComponentParser, _pointerToReactive)) {
      throw new DOMException("component cannot use interpolated attribute's names");
    }
    if (value == __privateGet(_ComponentParser, _pointerToReactive)) {
      numOfInterpolations++;
    }
    attributes.push(
      [name, value]
    );
  }
  return {
    isTag: true,
    tree: {
      isTextNode: false,
      attributes,
      children: [],
      tagName,
      reference: null,
      numOfInterpolations
    }
  };
};
compareWithReactivePointer_fn = function(string) {
  const keyword = __privateGet(_ComponentParser, _pointerToReactive);
  let j = 1;
  while (j < keyword.length) {
    if (keyword[j] !== string[j])
      return false;
    j++;
  }
  return true;
};
__privateAdd(_ComponentParser, _ComponentParser_static);
/**
 * it starts with a strange sequence for regular text. This is done for 
 * the parsing stage, to check if is regular text or is a keyword. If the compared text is not
 * this keyword, the check should end in maximum 4 characters.
 * @readonly
 */
__privateAdd(_ComponentParser, _pointerToReactive, "£:_--pRiVaTe__REACTIVE_PTR__v0.0/2024£");
/**
 * @readonly
 */
__privateAdd(_ComponentParser, _tagRegex, new RegExp(`<\\s*(${__privateGet(_ComponentParser, _pointerToReactive)}|([a-zA-Z][a-zA-Z0-9-]*))(\\s+(${__privateGet(_ComponentParser, _pointerToReactive)}|@?[a-zA-Z_:][a-zA-Z0-9_.:-]*)(\\s*=\\s*(?:"[^"]*"|'[^']*'|[^\\s>]*))?)*\\s*/?>`));
/**
 * @readonly
 */
__privateAdd(_ComponentParser, _tagAttrRegex, new RegExp(`((${__privateGet(_ComponentParser, _pointerToReactive)})|@?[a-zA-Z_:][a-zA-Z0-9_.:-]*)\\s*=\\s*(?:"([^"]*)"|'([^']*)'|([^\\s>]*))|([a-zA-Z_:][a-zA-Z0-9_.:-]*)`, "g"));
/**
 * @readonly
 */
__privateAdd(_ComponentParser, _tagNameRegex, new RegExp(`<\\s*(${__privateGet(_ComponentParser, _pointerToReactive)}|([a-zA-Z][a-zA-Z0-9-]*))`));
/**
 * @readonly
 */
__privateAdd(_ComponentParser, _closingTagRegex, /<\/\s*[a-zA-Z][a-zA-Z0-9-]*\s*>/);
/**
 * @readonly
 */
__privateAdd(_ComponentParser, _selfClosingTagRegex, /\s*\/>/);
var ComponentParser = _ComponentParser;

// node_modules/gloomjs/core/template/dom.js
var cloneElement = (leaf, tagName) => {
  if (leaf.reference && tagName == /**@type {HTMLElement}*/
  leaf.reference.tagName) {
    const node = (
      /**@type {HTMLElement}*/
      leaf.reference.cloneNode(false)
    );
    for (let i = 0; i < node.attributes.length; i++) {
      node.setAttribute(node.attributes[i][0], "");
    }
    return node;
  }
  leaf.reference = document.createElement(tagName);
  return leaf.reference;
};
var cloneText = (leaf, text) => {
  if (leaf.reference) {
    const textNode = leaf.reference.cloneNode(false);
    textNode.textContent = text;
    return (
      /**@type {Text}*/
      textNode
    );
  }
  leaf.reference = document.createTextNode(text);
  return leaf.reference;
};
var createElement = (name, leaf) => {
  if (leaf.isTextNode) {
    return {
      tag: [cloneText(leaf, name)],
      needAttributes: false,
      skipAttributes: false
    };
  }
  return {
    tag: [cloneElement(leaf, name)],
    needAttributes: true,
    skipAttributes: false
  };
};
var createComponent = (component, leaf, args, refToArgs, refIdx) => {
  return {
    tag: component.render({
      tree: leaf.children,
      args,
      refToArgs,
      idx: refIdx + 1
    }),
    usedArgs: leaf.numOfInterpolations,
    needAttributes: false,
    skipAttributes: false
  };
};
var createComponentList = (components, leaf, args, refToArgs, refIdx) => {
  const tree = [];
  if (!components.length) {
    tree.push(document.createTextNode(""));
    return {
      tag: tree,
      usedArgs: leaf.numOfInterpolations,
      needAttributes: false,
      skipAttributes: false
    };
  }
  for (let i = 0; i < components.length; i++) {
    tree.push(...components[i].render({
      tree: leaf.children,
      args,
      refToArgs,
      idx: refIdx + 1
    }));
  }
  return {
    tag: tree,
    usedArgs: leaf.numOfInterpolations,
    needAttributes: false,
    skipAttributes: false
  };
};
var createFromAnyReactive = (reactive, value, leaf, args, idx, refToArgs, refIdx) => {
  if (typeguard_default.Component(value)) {
    const res = createComponent(value, leaf, args.slice(idx, leaf.numOfInterpolations + 1), refToArgs, refIdx);
    const root = document.createTextNode("");
    const unsubscribe = reactive.subscribe({
      isComponent: true,
      root
    });
    res.tag.unshift(
      /**
       * @type {any}
       */
      root
    );
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isComponent: true,
        root: [root],
        isSubscription: true,
        subscription: null,
        children: leaf
      };
    } else {
      refToArgs[refIdx].root.push(root);
    }
    refIdx++;
    return {
      res,
      unsubscribe
    };
  } else if (typeguard_default.ComponentList(value)) {
    const res = createComponentList(value, leaf, args.slice(idx, leaf.numOfInterpolations + 1), refToArgs, refIdx);
    const root = document.createTextNode("");
    res.tag.unshift(
      /**
      * @type {any} 
      * otherwise it will throw error because is not HTMLElement and Text
      */
      root
    );
    const unsubscribe = reactive.subscribe({
      isComponent: true,
      root
    });
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isComponent: true,
        root: [root],
        isSubscription: true,
        subscription: null,
        children: leaf
      };
    } else {
      refToArgs[refIdx].root.push(root);
    }
    refIdx++;
    return {
      res,
      unsubscribe
    };
  } else if (leaf.isTextNode) {
    const ref = document.createTextNode(
      /**@type {string}*/
      value
    );
    const unsubscribe = reactive.subscribe({
      isComponent: false,
      root: ref,
      tagName: false,
      attributeValue: false,
      attribute: null,
      isTextNode: true
    });
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isTextNode: true,
        root: [ref],
        isSubscription: true,
        subscription: null
      };
    } else {
      refToArgs[refIdx].root.push(ref);
    }
    refIdx++;
    return {
      res: {
        usedArgs: 1,
        needAttributes: false,
        tag: [ref],
        skipAttributes: false
      },
      unsubscribe
    };
  } else {
    const ref = document.createElement(
      /**@type {string}*/
      value
    );
    const unsubscribe = reactive.subscribe({
      isComponent: false,
      root: ref,
      tagName: true,
      attributeValue: false,
      attribute: null,
      isTextNode: false
    });
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isTagName: true,
        root: [ref],
        isSubscription: true,
        subscription: null
      };
    } else {
      refToArgs[refIdx].root.push(ref);
    }
    refIdx++;
    return {
      res: {
        usedArgs: 1,
        needAttributes: true,
        tag: [ref],
        skipAttributes: false
      },
      unsubscribe
    };
  }
};

// node_modules/gloomjs/core/template/component.js
var isChildrenLeaf = (leaf, arg) => Boolean(leaf.tagName == "Children" || leaf.tagName == ComponentParser.pointerToReactive && typeof arg == "string" && arg == "Children");
var isRef = (value) => value && typeof value == "object" && "__isRef__" in value && value.__isRef__ && "element" in value && !Boolean(value.element);
var isScopedCss = (value) => value && typeof value == "object" && "__css__Key" in value && typeof value.__css__Key == "string";
var isComponentList = (value) => typeof value == "object" && value instanceof Array && (value[0] instanceof Component || value.length <= 0);
var areEquals = (s, o) => {
  if (s == o)
    return true;
  let flag = true;
  if (typeof s == "object" && typeof o == "object" && !(s instanceof Component) && !(o instanceof Component) && !isComponentList(s) && !isComponentList(o)) {
    Object.entries(o).every(([k, v]) => {
      if (!s[k] && s[k] != v)
        flag = false;
      flag = areEquals(s[k], v);
      return flag;
    });
  } else {
    flag = false;
  }
  return flag;
};
var _cachedTrees, _id, _pid, _cssKeys, _tree, _root, _args, _refToArgs, _subs2, _Component_instances, createRegisteredElement_fn, createElement_fn, setAttributes_fn, createDOMRecursive_fn, clearReferences_fn, updateInternalState_fn, updateAttributes_fn, updateComponents_fn;
var _Component = class _Component {
  /**
   * @param {TemplateStringsArray} html
   * @param {unknown[]} args
   * @hideconstructor
   */
  constructor(html2, ...args) {
    __privateAdd(this, _Component_instances);
    __privateAdd(this, _pid);
    /**
     * @type {Array<string>}
     */
    __privateAdd(this, _cssKeys, []);
    /**
     * @readonly
     * @type {Tree[]}
     */
    __privateAdd(this, _tree);
    /**
     * @type {Array<HTMLElement|Text>}
     */
    __privateAdd(this, _root);
    /**
     * @type {unknown[]}
     */
    __privateAdd(this, _args, []);
    /**
     * @type {Args[]}
     */
    __privateAdd(this, _refToArgs, []);
    /**
     * @type {ListRoot<()=>void>}
     */
    __privateAdd(this, _subs2, {
      head: null
    });
    /**
     * @type {Array<()=>void>}
     */
    __publicField(this, "__dispose", []);
    /**
     * @type {Array<()=>void>}
     */
    __publicField(this, "__mount", []);
    /**
     * @type {Array<(e: Error)=>void>}
     */
    __publicField(this, "__error", []);
    const template = ComponentParser.reduceTemplateStringArray(html2);
    const key = template.replaceAll(/\s+/ig, "");
    if (__privateGet(_Component, _cachedTrees).has(key)) {
      __privateSet(this, _tree, __privateGet(_Component, _cachedTrees).get(key).tree);
    } else {
      __privateSet(this, _tree, ComponentParser.createHtmlTree(template));
      __privateGet(_Component, _cachedTrees).set(key, {
        tree: __privateGet(this, _tree)
      });
    }
    __privateSet(this, _pid, __privateWrapper(_Component, _id)._++);
    __privateSet(this, _refToArgs, new Array(args.length));
    __privateSet(this, _args, args);
  }
  /**
   * @type {Readonly<unknown[]>}
   */
  get args() {
    return __privateGet(this, _args);
  }
  /**
   * @param {Children} children 
   * @return {HTMLElement[]}
   */
  render(children) {
    if (__privateGet(this, _root) && __privateGet(this, _root).length > 0) {
      for (let i = 0; i < this.__mount.length; i++) {
        this.__mount[i]();
      }
      return (
        /**@type {HTMLElement[]}*/
        [...__privateGet(this, _root)]
      );
    }
    try {
      const {
        idx: _,
        childList
      } = __privateMethod(this, _Component_instances, createDOMRecursive_fn).call(this, __privateGet(this, _tree), children, __privateGet(this, _args), 0, __privateGet(this, _refToArgs), 0);
      __privateSet(this, _root, childList);
      const tree = (
        /**@type {HTMLElement[]}*/
        [...__privateGet(this, _root)]
      );
      for (let i = 0; i < this.__mount.length; i++) {
        this.__mount[i]();
      }
      return tree;
    } catch (e) {
      for (let i = 0; i < this.__error.length; i++) {
        this.__error[i](e);
      }
      console.error(e);
    }
    return [];
  }
  /**
   * for all(args) if arg[i] != old(arg[i]) => update
   * if the arg is a component of the same type as the old one, require update, 
   * otherwise change component
   * @param  {...unknown} args 
   */
  update(...args) {
    try {
      const toUpdate = __privateMethod(this, _Component_instances, updateInternalState_fn).call(this, ...args);
      const components = __privateMethod(this, _Component_instances, updateAttributes_fn).call(this, toUpdate);
      __privateMethod(this, _Component_instances, updateComponents_fn).call(this, components);
    } catch (e) {
      for (let i = 0; i < this.__error.length; i++) {
        this.__error[i](e);
      }
      console.log(e);
    }
  }
  /**
   * dispose a component by unsubscribing all it's dependencies and
   * by removing all the tree associated with it from the dom
   */
  dispose() {
    let curr = __privateGet(this, _subs2).head;
    while (curr) {
      curr.value();
      curr = curr.next;
    }
    for (let i = 0; i < __privateGet(this, _root).length; i++) {
      __privateGet(this, _root)[i].remove();
    }
    for (let i = 0; i < this.__dispose.length; i++) {
      this.__dispose[i]();
    }
  }
  /**
   * @param {Component} other 
   */
  isEqualTo(other) {
    if (__privateGet(this, _tree) == __privateGet(other, _tree)) {
      return true;
    }
    return false;
  }
};
_cachedTrees = new WeakMap();
_id = new WeakMap();
_pid = new WeakMap();
_cssKeys = new WeakMap();
_tree = new WeakMap();
_root = new WeakMap();
_args = new WeakMap();
_refToArgs = new WeakMap();
_subs2 = new WeakMap();
_Component_instances = new WeakSet();
/**
 * returns the html instance of the component passed as input
 * @param {Readonly<Tree>} leaf
 * @param {unknown[]} args
 * @param {number} idx 
 * @param {number} refIdx represents the index used by refToArgs
 * @param {Args[]} refToArgs
 */
createRegisteredElement_fn = function(leaf, args, idx, refToArgs, refIdx) {
  const props = {};
  const boundKeys = [];
  let numOfArgs = 0;
  for (let i = 0; i < leaf.attributes.length; i++) {
    const value = leaf.attributes[i][1];
    if (typeof value == "string" && value.indexOf(ComponentParser.pointerToReactive) >= 0) {
      props[leaf.attributes[i][0]] = args[idx + numOfArgs];
      boundKeys.push(leaf.attributes[i][0]);
      numOfArgs++;
    } else {
      props[leaf.attributes[i][0]] = leaf.attributes[i][1];
    }
  }
  const component = _Component.__register.get(leaf.tagName)(props);
  let root;
  let res;
  if (component instanceof _Component) {
    res = createComponent(
      component,
      leaf,
      numOfArgs < leaf.numOfInterpolations ? args.slice(idx + numOfArgs, idx + leaf.numOfInterpolations) : [],
      refToArgs,
      refIdx + numOfArgs
    );
    root = document.createTextNode("");
    res.tag[0].before(root);
    res.usedArgs = res.usedArgs > numOfArgs ? res.usedArgs - numOfArgs : numOfArgs;
    res.skipAttributes = true;
  } else if (isComponentList(component)) {
    res = createComponentList(
      component,
      leaf,
      numOfArgs < leaf.numOfInterpolations ? args.slice(idx + numOfArgs, idx + leaf.numOfInterpolations) : [],
      refToArgs,
      refIdx + numOfArgs
    );
    root = document.createTextNode("");
    res.tag[0].before(root);
    res.usedArgs = res.usedArgs > numOfArgs ? res.usedArgs - numOfArgs : numOfArgs;
    res.skipAttributes = true;
  } else {
    res = {
      ...createElement(leaf.tagName, leaf),
      needAttributes: false,
      usedArgs: numOfArgs,
      // skip the "skipping-phase"
      skipAttributes: true
    };
    root = res.tag[0];
  }
  if (!refToArgs[refIdx]) {
    refToArgs[refIdx] = {
      isRegisteredComponent: true,
      root: [root],
      props,
      children: leaf,
      component: {
        name: leaf.tagName,
        instance: component
      },
      boundKeys
    };
  } else {
    refToArgs[refIdx].root.push(root);
  }
  return res;
};
/**
 * returns the html instance of the component passed as input
 * @param {Readonly<Tree>} leaf
 * @param {unknown[]} args
 * @param {number} idx 
 * @param {number} refIdx represents the index used by refToArgs
 * @param {Args[]} refToArgs
 * @returns {RenderingResult}
 */
createElement_fn = function(leaf, args, idx, refToArgs, refIdx) {
  if (_Component.__register.has(leaf.tagName)) {
    return __privateMethod(this, _Component_instances, createRegisteredElement_fn).call(this, leaf, args, idx, refToArgs, refIdx);
  }
  const value = args[idx];
  if (leaf.tagName !== ComponentParser.pointerToReactive) {
    return {
      ...createElement(leaf.tagName, leaf),
      usedArgs: 0
    };
  }
  if (value instanceof _Component) {
    const res2 = createComponent(value, leaf, args.slice(idx + 1, leaf.numOfInterpolations + 1), refToArgs, refIdx);
    const root = document.createTextNode("");
    res2.tag[0].before(root);
    res2.tag.unshift(root);
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isComponent: true,
        root: [root],
        children: leaf
      };
    } else {
      refToArgs[refIdx].root.push(root);
    }
    return res2;
  } else if (isComponentList(value)) {
    const res2 = createComponentList(value, leaf, args.slice(idx + 1, leaf.numOfInterpolations + 1), refToArgs, refIdx);
    const root = document.createTextNode("");
    res2.tag[0].before(root);
    res2.tag.unshift(root);
    if (!refToArgs[refIdx]) {
      refToArgs[refIdx] = {
        isComponent: true,
        root: [root],
        children: leaf
      };
    } else {
      refToArgs[refIdx].root.push(root);
    }
    return res2;
  } else if (value instanceof Signal) {
    const { unsubscribe, res: res2 } = createFromAnyReactive(value, value.value, leaf, args, idx, refToArgs, refIdx);
    append(
      __privateGet(this, _subs2),
      unsubscribe
    );
    if (!refToArgs[refIdx].subscription) {
      refToArgs[refIdx].subscription = [__privateGet(this, _subs2).head];
    } else {
      refToArgs[refIdx].subscription.push(__privateGet(this, _subs2).head);
    }
    return res2;
  } else if (value instanceof Effect) {
    const { unsubscribe, res: res2 } = createFromAnyReactive(value, value.state, leaf, args, idx, refToArgs, refIdx);
    append(
      __privateGet(this, _subs2),
      unsubscribe
    );
    if (!refToArgs[refIdx].subscription) {
      refToArgs[refIdx].subscription = [__privateGet(this, _subs2).head];
    } else {
      refToArgs[refIdx].subscription.push(__privateGet(this, _subs2).head);
    }
    return res2;
  }
  const res = createElement(
    /**@type {string}*/
    value,
    leaf
  );
  if (!refToArgs[refIdx]) {
    refToArgs[refIdx] = {
      isTagName: true,
      root: [res.tag[0]],
      isTextNode: leaf.isTextNode
    };
  } else {
    refToArgs[refIdx].root.push(res.tag[0]);
  }
  return {
    ...res,
    usedArgs: 1
  };
};
/**
 * 
 * @param {HTMLElement} tag 
 * @param {[string,unknown][]} attributes 
 * @param {unknown[]} args 
 * @param {number} idx 
 * @param {number} refIdx represents the index used by refToArgs
 * @param {Args[]} refToArgs
 * @returns {number} 
 */
setAttributes_fn = function(tag, attributes, args, idx, refToArgs, refIdx) {
  for (let i = 0; i < attributes.length; i++) {
    if (attributes[i][1] == ComponentParser.pointerToReactive) {
      const arg = args[idx];
      if (arg instanceof Signal) {
        tag.setAttribute(
          attributes[i][0],
          /**@type {string}*/
          arg.value
        );
        const unsubscribe = arg.subscribe({
          isComponent: false,
          attribute: attributes[i][0],
          root: tag,
          attributeValue: true,
          tagName: false,
          isTextNode: false
        });
        append(
          __privateGet(this, _subs2),
          unsubscribe
        );
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            attribute: attributes[i][0],
            root: [tag],
            isAttributeValue: true,
            isSubscription: true,
            subscription: [__privateGet(this, _subs2).head]
          };
        } else {
          refToArgs[refIdx].root.push(tag);
          refToArgs[refIdx].subscription.push(__privateGet(this, _subs2).head);
        }
      } else if (arg instanceof Effect) {
        const unsubscribe = arg.subscribe({
          isComponent: false,
          attribute: attributes[i][0],
          root: tag,
          attributeValue: true,
          tagName: false,
          isTextNode: false
        });
        append(
          __privateGet(this, _subs2),
          unsubscribe
        );
        tag.setAttribute(
          attributes[i][0],
          /**@type {string}*/
          arg.state
        );
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            attribute: attributes[i][0],
            root: [tag],
            isAttributeValue: true,
            isSubscription: true,
            subscription: [__privateGet(this, _subs2).head]
          };
        } else {
          refToArgs[refIdx].root.push(tag);
          refToArgs[refIdx].subscription.push(__privateGet(this, _subs2).head);
        }
      } else if (typeof arg == "function" && attributes[i][0][0] == "@") {
        tag.addEventListener(
          attributes[i][0].slice(1),
          /**@type {(e)=>void}*/
          arg
        );
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            attribute: attributes[i][0],
            root: [tag],
            isEvent: true
          };
        } else {
          refToArgs[refIdx].root.push(tag);
        }
      } else if (isRef(arg)) {
        arg.element = tag;
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            root: [tag],
            isRef: true,
            ref: arg
          };
        } else {
          refToArgs[refIdx].root.push(tag);
        }
      } else if (isScopedCss(arg)) {
        __privateGet(this, _cssKeys).push(arg.__css__Key);
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            root: [tag],
            isCssKey: true
          };
        } else {
          refToArgs[refIdx].root.push(tag);
        }
      } else {
        tag.setAttribute(
          attributes[i][0],
          /**@type {string}*/
          arg
        );
        if (!refToArgs[refIdx]) {
          refToArgs[refIdx] = {
            attribute: attributes[i][0],
            root: [tag],
            isAttributeValue: true
          };
        } else {
          refToArgs[refIdx].root.push(tag);
        }
      }
      idx++;
      refIdx++;
    } else {
      tag.setAttribute(
        attributes[i][0],
        /**@type {string}*/
        attributes[i][1]
      );
    }
  }
  __privateGet(this, _cssKeys).length && tag.classList.add(...__privateGet(this, _cssKeys));
  return idx;
};
/**
 * 
 * @param {Tree[]} tree 
 * @param {Children} children
 * @param {unknown[]} args 
 * @param {number} idx 
 * @param {number} refIdx represents the index used by refToArgs
 * @param {Args[]} refToArgs represent the reference to that links an arg to the actual dom leaf
 * @throws {DOMException} if a children with attributes/children is found
 */
createDOMRecursive_fn = function(tree, children, args, idx, refToArgs, refIdx) {
  const fatherList = [];
  for (let i = 0; i < tree.length; i++) {
    const leaf = tree[i];
    if (isChildrenLeaf(leaf, args[idx])) {
      if (leaf.children.length > 0 || leaf.attributes.length > 0) {
        throw new DOMException("'Children' tag must be self-closing without attributes");
      }
      const { childList: list, idx: _ } = __privateMethod(this, _Component_instances, createDOMRecursive_fn).call(this, children.tree, {
        tree: [],
        args: [],
        refToArgs: [],
        idx: 0
      }, children.args, 0, children.refToArgs, children.idx);
      fatherList.push(...list);
      continue;
    }
    const {
      tag: tagList,
      needAttributes,
      usedArgs,
      skipAttributes
    } = __privateMethod(this, _Component_instances, createElement_fn).call(this, leaf, args, idx, refToArgs, refIdx);
    fatherList.push(...tagList);
    idx += usedArgs;
    refIdx += usedArgs;
    if (needAttributes) {
      const usedArgs2 = __privateMethod(this, _Component_instances, setAttributes_fn).call(
        this,
        /**@type {HTMLElement}*/
        tagList[0],
        leaf.attributes,
        args,
        idx,
        refToArgs,
        refIdx
      );
      refIdx += usedArgs2 - idx;
      idx = usedArgs2;
    } else if (!skipAttributes) {
      for (let j = 0; j < leaf.attributes.length; j++) {
        if (leaf.attributes[j][1] == ComponentParser.pointerToReactive) {
          refToArgs[refIdx] = {
            root: [],
            attribute: leaf.attributes[j][0],
            isAttributeValue: true
          };
          idx++;
          refIdx++;
        }
      }
    }
    if (tagList.length == 1) {
      if (leaf.children.length) {
        const { childList, idx: index } = __privateMethod(this, _Component_instances, createDOMRecursive_fn).call(this, leaf.children, children, args, idx, refToArgs, refIdx);
        refIdx += index - idx;
        tagList[0].append(...childList);
        idx = index;
      }
    }
  }
  return {
    childList: fatherList,
    idx
  };
};
/**
 * removes subscriptions, refs (etc...) from the args
 * @param {number} i
 */
clearReferences_fn = function(i) {
  if (__privateGet(this, _refToArgs)[i].isSubscription) {
    const subs = __privateGet(this, _refToArgs)[i].subscription;
    for (let j = 0; j < subs.length; j++) {
      subs[j].value();
      remove(
        __privateGet(this, _subs2),
        subs[j]
      );
    }
  } else if (__privateGet(this, _refToArgs)[i].isRef) {
    __privateGet(this, _refToArgs)[i].ref.element = null;
  } else if (__privateGet(this, _refToArgs)[i].isEvent) {
    const roots = __privateGet(this, _refToArgs)[i].root;
    for (let j = 0; j < roots.length; j++) {
      roots[j].removeEventListener(
        __privateGet(this, _refToArgs)[i].attribute.slice(1),
        /**@type {(e: Event)=>void}*/
        __privateGet(this, _args)[i]
      );
    }
  }
};
/**
 * if the old arg is different from the new arg, it updates it and mark
 * the corresponding refToArgs as dirty, so that the fw 
 * now where it needs to update.
 * @param  {...unknown} args 
 * @returns {number[]}
 */
updateInternalState_fn = function(...args) {
  const toUpdate = [];
  for (let i = 0; i < args.length; i++) {
    const self = __privateGet(this, _args)[i];
    const other = args[i];
    if (__privateGet(this, _refToArgs)[i] && __privateGet(this, _refToArgs)[i].isRegisteredComponent) {
      for (let j = 0; j < __privateGet(this, _refToArgs)[i].boundKeys.length; j++) {
        __privateGet(this, _refToArgs)[i].props[__privateGet(this, _refToArgs)[i].boundKeys[j]] = args[i + j];
      }
      const self2 = __privateGet(this, _refToArgs)[i].component.instance;
      const other2 = _Component.__register.get(__privateGet(this, _refToArgs)[i].component.name)(__privateGet(this, _refToArgs)[i].props);
      if (self2.isEqualTo(other2)) {
        self2.update(__privateGet(this, _refToArgs)[i].props);
      } else {
        self2.dispose();
        __privateGet(this, _refToArgs)[i].component.instance = other2;
      }
      i += __privateGet(this, _refToArgs)[i].boundKeys.length;
    }
    if (areEquals(self, other)) {
      const roots = __privateGet(this, _refToArgs)[i].root;
      if (__privateGet(this, _refToArgs)[i].isAttributeValue) {
        let value = self;
        if (self instanceof Effect) {
          value = self.state;
        } else if (self instanceof Signal) {
          value = self.value;
        }
        for (let j = 0; j < roots.length; j++) {
          roots[j].setAttribute(
            __privateGet(this, _refToArgs)[i].attribute,
            /**@type {string}*/
            value
          );
        }
      }
      continue;
    }
    toUpdate.push(i);
    if (self instanceof _Component && other instanceof _Component) {
      if (self.isEqualTo(other)) {
        self.update(...__privateGet(other, _args));
      } else {
        self.dispose();
        __privateGet(this, _args)[i] = other;
      }
    } else if (isComponentList(self) && isComponentList(other)) {
      const minLen = other.length < self.length ? other.length : self.length;
      for (let j = 0; j < minLen; j++) {
        const s = self[j];
        const o = other[j];
        if (!(s instanceof _Component) || !(o instanceof _Component))
          throw new TypeError("array of components must be homogeneous");
        if (s.isEqualTo(o)) {
          s.update(...__privateGet(o, _args));
        } else {
          s.dispose();
          self[j] = o;
        }
      }
      if (minLen == other.length) {
        for (let j = minLen; j < self.length; j++) {
          const s = self[j];
          if (!(s instanceof _Component))
            throw new TypeError("array of components must be homogeneous");
          s.dispose();
        }
        self.length = minLen;
      } else {
        for (let j = minLen; j < other.length; j++) {
          const o = other[j];
          if (!(o instanceof _Component))
            throw new TypeError("array of components must be homogeneous");
          self.push(o);
        }
      }
    } else {
      if (other instanceof _Component) {
        __privateMethod(this, _Component_instances, clearReferences_fn).call(this, i);
        __privateGet(this, _refToArgs)[i] = {
          isComponent: true,
          root: __privateGet(this, _refToArgs)[i].root
        };
      } else if (isComponentList(other)) {
        __privateMethod(this, _Component_instances, clearReferences_fn).call(this, i);
        __privateGet(this, _refToArgs)[i] = {
          isComponent: true,
          root: __privateGet(this, _refToArgs)[i].root
        };
      } else if (other instanceof Signal || other instanceof Effect) {
        __privateMethod(this, _Component_instances, clearReferences_fn).call(this, i);
        __privateGet(this, _refToArgs)[i].isSubscription = true;
        __privateGet(this, _refToArgs)[i].subscription = [];
        for (let j = 0; j < __privateGet(this, _refToArgs)[i].root.length; j++) {
          const unsubscribe = other.subscribe({
            isComponent: __privateGet(this, _refToArgs)[i].isComponent,
            root: __privateGet(this, _refToArgs)[i].root[i],
            tagName: __privateGet(this, _refToArgs)[i].isTagName,
            attributeValue: __privateGet(this, _refToArgs)[i].isAttributeValue,
            attribute: __privateGet(this, _refToArgs)[i].attribute,
            isTextNode: __privateGet(this, _refToArgs)[i].isTextNode
          });
          append(
            __privateGet(this, _subs2),
            unsubscribe
          );
          __privateGet(this, _refToArgs)[i].subscription.push(__privateGet(this, _subs2).head);
        }
      } else if (isRef(other)) {
        __privateMethod(this, _Component_instances, clearReferences_fn).call(this, i);
        __privateGet(this, _refToArgs)[i] = {
          isRef: true,
          root: __privateGet(this, _refToArgs)[i].root,
          ref: other
        };
      } else if (__privateGet(this, _refToArgs)[i].isTextNode || __privateGet(this, _refToArgs)[i].isTagName || __privateGet(this, _refToArgs)[i].isAttributeValue || __privateGet(this, _refToArgs)[i].isEvent) {
        __privateMethod(this, _Component_instances, clearReferences_fn).call(this, i);
      } else if (!__privateGet(this, _refToArgs)[i].isCssKey) {
        throw new TypeError("no match for the type you are interpolating");
      }
      __privateGet(this, _args)[i] = other;
    }
  }
  return toUpdate;
};
/**
 * update every arg that is not a component.
 * this is done to not cause precedence problems 
 * with children
 * @param {readonly number[]} toUpdate 
 */
updateAttributes_fn = function(toUpdate) {
  const components = [];
  for (let j = 0; j < toUpdate.length; j++) {
    const i = toUpdate[j];
    const self = __privateGet(this, _args)[i];
    const roots = __privateGet(this, _refToArgs)[i].root;
    let value = self;
    if (self instanceof Effect) {
      value = self.state;
    } else if (self instanceof Signal) {
      value = self.value;
    }
    if (__privateGet(this, _refToArgs)[i].isComponent) {
      components.push(i);
    } else if (__privateGet(this, _refToArgs)[i].isEvent) {
      for (let j2 = 0; j2 < roots.length; j2++) {
        roots[j2].addEventListener(
          __privateGet(this, _refToArgs)[i].attribute.slice(1),
          /**@type {(e: Event)=>void}*/
          self
        );
      }
    } else if (__privateGet(this, _refToArgs)[i].isAttributeValue) {
      for (let j2 = 0; j2 < roots.length; j2++) {
        roots[j2].setAttribute(
          __privateGet(this, _refToArgs)[i].attribute,
          /**@type {string}*/
          value
        );
      }
    } else if (__privateGet(this, _refToArgs)[i].isRef) {
      self.element = roots.at(-1);
    } else if (__privateGet(this, _refToArgs)[i].isTextNode) {
      for (let i2 = 0; i2 < roots.length; i2++) {
        roots[i2].textContent = /**@type {string}*/
        value;
      }
    } else if (__privateGet(this, _refToArgs)[i].isTagName) {
      for (let i2 = 0; i2 < roots.length; i2++) {
        const node = document.createElement(
          /**@type {string}*/
          value
        );
        const attrib = (
          /**@type {HTMLElement}*/
          roots[i2].attributes
        );
        for (let i3 = 0; i3 < attrib.length; i3++) {
          node.setAttribute(
            attrib[i3][0],
            attrib[i3][1]
          );
        }
      }
    }
  }
  return components;
};
/**
 * update all the args that **are** components.
 * @param {readonly number[]} components 
 */
updateComponents_fn = function(components) {
  for (let i = components.length - 1; i >= 0; i--) {
    const idx = components[i];
    const self = __privateGet(this, _args)[idx];
    const desc = __privateGet(this, _refToArgs)[idx];
    if (self instanceof _Component) {
      desc.root.at(-1).after(
        ...self.render({
          tree: desc.children.children,
          args: __privateGet(this, _args).slice(idx + 1, desc.children.numOfInterpolations + 1),
          refToArgs: [],
          idx: 0
        })
      );
    } else if (isComponentList(self)) {
      const tree = [];
      for (let i2 = 0; i2 < self.length; i2++) {
        tree.push(...self[i2].render({
          tree: desc.children.children,
          args: __privateGet(this, _args).slice(idx + 1, desc.children.numOfInterpolations + 1),
          refToArgs: [],
          idx: 0
        }));
      }
      desc.root.at(-1).after(...tree);
    }
  }
};
/**
 * @type {Map<string,{ tree: Tree[] }>}
 */
__privateAdd(_Component, _cachedTrees, /* @__PURE__ */ new Map());
/**
 * @type {Map<string, (args: Record<string,unknown>) => Component>}
 */
__publicField(_Component, "__register", /* @__PURE__ */ new Map());
__privateAdd(_Component, _id, 0);
var Component = _Component;

// node_modules/gloomjs/core/template/typeguard.js
var is = {
  /**
   * check if object is an effect
   * @param {unknown} value 
   * @returns {value is Effect}
   */
  Effect: (value) => value && value instanceof Effect,
  /**
   * check if object is an effect
   * @param {unknown} value 
   * @returns {value is Signal}
   */
  Reactive: (value) => value && value instanceof Signal,
  /**
   * check if object is a Ref
   * @param {unknown} value 
   * @returns {value is Ref<HTMLElement>}
   */
  Ref: (value) => value && typeof value == "object" && "__isRef__" in value && value.__isRef__ && "element" in value && !Boolean(value.element),
  /**
   * true if the leaf is `<Children/>`
   * @param {Tree} leaf 
   * @param {unknown} arg 
   * @returns {boolean} 
   */
  ChildrenLeaf: (leaf, arg) => Boolean(leaf.tagName == "Children" || leaf.tagName == ComponentParser.pointerToReactive && typeof arg == "string" && arg == "Children"),
  /**
   * 
   * @param {unknown} value 
   * @returns {value is Component}
   */
  Component: (value) => typeof value == "object" && value instanceof Component,
  /**
   * check if object is a component list
   * note, it only checks the first and the last elements, 
   * ### if the first and the last elements are a Component, **all** the list will be rendered as a component
   * @param {unknown} value 
   * @returns {value is Component[]}
   */
  ComponentList: (value) => typeof value == "object" && value instanceof Array && (value[0] instanceof Component || value.length <= 0)
};
var typeguard_default = is;

// node_modules/gloomjs/core/reactivity/effect.js
var _state, _refCounter, _callback, _subs3, _unsubscribe, _dependencies, _Effect_instances, updateState_fn;
var Effect = class {
  /**
   * @param {() => T} callback 
   * @param  {...Signal<unknown>} deps 
   */
  constructor(callback, ...deps) {
    __privateAdd(this, _Effect_instances);
    /**
     * @type {T}
     */
    __privateAdd(this, _state);
    /**
     * @type {number}
     */
    __privateAdd(this, _refCounter, 0);
    /**
     * @readonly
     * @type {() => T}
     */
    __privateAdd(this, _callback);
    /**
     * list of subscriptions
     * @type {ListRoot<ReactiveRef>}
     */
    __privateAdd(this, _subs3, {
      head: null
    });
    /**
     * list of function used to unsubscribe from
     * all the dependencies
     * @type {ListRoot<() => void>}
     */
    __privateAdd(this, _unsubscribe, {
      head: null
    });
    /**
     * @readonly
     * @type {Signal<unknown>[]}
     */
    __privateAdd(this, _dependencies);
    __privateSet(this, _dependencies, deps);
    __privateSet(this, _state, callback());
    __privateSet(this, _callback, callback);
  }
  get state() {
    return __privateGet(this, _state);
  }
  /**
   * return the function used to unsubscribe the subscription
   * @param {ReactiveRef} ref 
   */
  subscribe(ref) {
    if (__privateGet(this, _refCounter) <= 0) {
      for (let i = 0; i < __privateGet(this, _dependencies).length; i++) {
        append(
          __privateGet(this, _unsubscribe),
          __privateGet(this, _dependencies)[i].subscribeEffect(this)
        );
      }
    }
    append(
      __privateGet(this, _subs3),
      ref
    );
    __privateWrapper(this, _refCounter)._++;
    const ticket = __privateGet(this, _subs3).head;
    return () => {
      __privateWrapper(this, _refCounter)._--;
      remove(
        __privateGet(this, _subs3),
        ticket
      );
      if (__privateGet(this, _refCounter) <= 0) {
        let curr = __privateGet(this, _unsubscribe).head;
        while (curr) {
          curr.value();
          curr = curr.next;
        }
        __privateGet(this, _unsubscribe).head = null;
      }
    };
  }
  /**
   * update will work as follows:
   * there will be a variable called refCounter,
   * that tracks the number of components linked to this effect.
   * if the effect reaches 0 refCount, it unsubscribe from every signal associated with
   * it. on update, it will call the callback associated with the method, then it will update
   * all the components linked to it
   */
  update() {
    __privateMethod(this, _Effect_instances, updateState_fn).call(this);
    let curr = __privateGet(this, _subs3).head;
    while (curr) {
      if (curr.value.isComponent) {
        const desc = (
          /**@type {ComponentRef}*/
          curr.value
        );
        if (typeguard_default.ComponentList(__privateGet(this, _state))) {
          const tree = [];
          for (let i = 0; i < __privateGet(this, _state).length; i++) {
            tree.push(...__privateGet(this, _state)[i].render({ args: [], tree: [], refToArgs: [], idx: 0 }));
          }
          desc.root.after(...tree);
        } else if (typeguard_default.Component(__privateGet(this, _state))) {
          desc.root.after(
            ...__privateGet(this, _state).render({ args: [], tree: [], refToArgs: [], idx: 0 })
          );
        }
      } else {
        const desc = (
          /**@type {SimpleRef}*/
          curr.value
        );
        if (desc.attributeValue) {
          desc.root.setAttribute(
            desc.attribute,
            /**@type {string}*/
            __privateGet(this, _state)
          );
        } else if (desc.isTextNode) {
          desc.root.textContent = /**@type {string}*/
          __privateGet(this, _state);
        } else {
          const node = document.createElement(
            /**@type {string}*/
            __privateGet(this, _state)
          );
          desc.root.replaceWith(node);
          desc.root = node;
        }
      }
      curr = curr.next;
    }
  }
};
_state = new WeakMap();
_refCounter = new WeakMap();
_callback = new WeakMap();
_subs3 = new WeakMap();
_unsubscribe = new WeakMap();
_dependencies = new WeakMap();
_Effect_instances = new WeakSet();
updateState_fn = function() {
  const state = __privateGet(this, _callback).call(this);
  if (state && typeof state !== "object" && __privateGet(this, _state) == state) {
    return;
  }
  if (typeguard_default.Component(__privateGet(this, _state))) {
    if (typeguard_default.Component(state) && __privateGet(this, _state).isEqualTo(state)) {
      __privateGet(this, _state).update(...state.args);
    } else {
      __privateGet(this, _state).dispose();
      __privateSet(this, _state, state);
    }
  } else if (typeguard_default.ComponentList(__privateGet(this, _state))) {
    if (typeguard_default.ComponentList(state)) {
      const minLen = __privateGet(this, _state).length > state.length ? state.length : __privateGet(this, _state).length;
      for (let i = 0; i < minLen; i++) {
        if (__privateGet(this, _state)[i].isEqualTo(state[i])) {
          __privateGet(this, _state)[i].update(...state[i].args);
        } else {
          __privateGet(this, _state)[i].dispose();
          __privateGet(this, _state)[i] = state[i];
        }
      }
      if (minLen == state.length) {
        for (let i = minLen; i < __privateGet(this, _state).length; i++) {
          __privateGet(this, _state)[i].dispose();
        }
        __privateGet(this, _state).splice(minLen, __privateGet(this, _state).length - minLen);
      } else {
        __privateGet(this, _state).push(...state.slice(minLen));
      }
    } else {
      for (let i = 0; i < __privateGet(this, _state).length; i++) {
        __privateGet(this, _state)[i].dispose();
      }
      __privateSet(this, _state, state);
    }
  } else {
    __privateSet(this, _state, state);
  }
};

// node_modules/gloomjs/core/css/index.js
var _keyId, _styleRoot, _key, _styleCache, _css, _styleKey, _CssParser_instances, getNextSelectorIndex_fn, scopeSelectors_fn, scope_fn;
var _CssParser = class _CssParser {
  /**
   * 
   * @param {string} css 
   */
  constructor(css2) {
    __privateAdd(this, _CssParser_instances);
    /**
     * @readonly
     * @type {string}
     */
    __privateAdd(this, _css);
    /**
     * @type {string}
     */
    __privateAdd(this, _styleKey);
    __privateSet(this, _css, css2.replace(/\s+/ig, " "));
  }
  scope() {
    if (__privateGet(_CssParser, _styleCache).has(__privateGet(this, _css))) {
      return __privateGet(_CssParser, _styleCache).get(__privateGet(this, _css));
    }
    __privateSet(this, _styleKey, __privateGet(_CssParser, _key) + __privateWrapper(_CssParser, _keyId)._++);
    const scoped = __privateMethod(this, _CssParser_instances, scope_fn).call(this, __privateGet(this, _css));
    if (!__privateGet(_CssParser, _styleRoot)) {
      __privateSet(_CssParser, _styleRoot, document.createElement("style"));
      __privateGet(_CssParser, _styleRoot).type = "text/css";
      document.head.appendChild(__privateGet(_CssParser, _styleRoot));
    }
    __privateGet(_CssParser, _styleRoot).append(scoped);
    __privateGet(_CssParser, _styleCache).set(__privateGet(this, _css), {
      __css__Key: __privateGet(this, _styleKey).replace(".", "")
    });
    return {
      __css__Key: __privateGet(this, _styleKey).replace(".", "")
    };
  }
};
_keyId = new WeakMap();
_styleRoot = new WeakMap();
_key = new WeakMap();
_styleCache = new WeakMap();
_css = new WeakMap();
_styleKey = new WeakMap();
_CssParser_instances = new WeakSet();
/**
 * returns the next same-level selector. the index is the index of the last '}'
 * @param {number} styleStart 
 * @param {string} cssString 
 */
getNextSelectorIndex_fn = function(styleStart, cssString) {
  let openBrackets = 1;
  let j = styleStart + 1;
  while (openBrackets > 0 && j < cssString.length) {
    if (cssString[j] == "}") {
      openBrackets--;
    } else if (cssString[j] == "{") {
      openBrackets++;
    }
    j++;
  }
  return j;
};
/**
 * 
 * @param {string} selectors 
 */
scopeSelectors_fn = function(selectors) {
  return selectors.split(/([,&>|+~ <])(?!\=)/ig).map((v) => {
    if (!v.length || v.match(/([,&>|+~ <])/) && v.length == 1)
      return v;
    if (v.indexOf("[") >= 0 || v.indexOf(":") >= 0) {
      return v.replace(/[a-zA-Z0-9_-][\[:]/, (m) => m[0] + __privateGet(this, _styleKey) + m[1]);
    }
    return v + __privateGet(this, _styleKey);
  }).reduce((p, c) => p + c);
};
/**
 * 
 * @param {string} cssString 
 * @returns 
 */
scope_fn = function(cssString) {
  let res = "";
  let i = 0;
  while (i < cssString.length) {
    const styleStart = cssString.indexOf("{", i);
    if (i < 0) {
      return res + cssString.slice(i);
    }
    const sel = cssString.slice(i, styleStart);
    if (sel.indexOf("@media") >= 0) {
      const next2 = __privateMethod(this, _CssParser_instances, getNextSelectorIndex_fn).call(this, styleStart, cssString);
      const scoped = __privateMethod(this, _CssParser_instances, scope_fn).call(this, cssString.slice(styleStart + 1, next2));
      res += sel + "{" + scoped;
      i = next2 + 1;
      continue;
    } else if (sel.indexOf("@keyframe") >= 0) {
      const j = __privateMethod(this, _CssParser_instances, getNextSelectorIndex_fn).call(this, styleStart, cssString);
      res += cssString.slice(i, j + 1);
      i = j + 1;
      continue;
    }
    let next = __privateMethod(this, _CssParser_instances, getNextSelectorIndex_fn).call(this, styleStart, cssString);
    res += __privateMethod(this, _CssParser_instances, scopeSelectors_fn).call(this, sel) + cssString.slice(styleStart, next + 1);
    i = next + 1;
  }
  return res;
};
__privateAdd(_CssParser, _keyId, Math.trunc(Math.random() * 5760 + Math.random() * 1254 + 4578));
/**
 * @type {HTMLStyleElement}
 */
__privateAdd(_CssParser, _styleRoot);
/**
 * note, this is 
 * a CSS class
 * @readonly
 */
__privateAdd(_CssParser, _key, ".--Component--Scope__Key__");
/**
 * holds the key of the style.
 * the style is the key of the hashmap
 * @type {Map<string,ScopedCss>}
 */
__privateAdd(_CssParser, _styleCache, /* @__PURE__ */ new Map());
var CssParser = _CssParser;
var css = (strings, ...args) => {
  let res = strings[0];
  for (let i = 0; i < args.length; i++) {
    res += args[i] + strings[i + 1];
  }
  return new CssParser(res).scope();
};

// node_modules/gloomjs/core/index.js
var html = (strings, ...args) => {
  return new Component(strings, ...args);
};
var createRoot = (component, root) => {
  root.append(...component.render({ tree: [], args: [], refToArgs: [], idx: 0 }));
};
var createContext = (ctx) => {
  return () => {
    return ctx;
  };
};
var $signal = (value) => new Signal(value);
var $effect = (value, ...states) => new Effect(value, ...states);
var $watcher = (callback, signal) => signal.subscribeEffect({ update: callback });
var $ref = () => {
  return {
    element: void 0,
    __isRef__: true
  };
};
var useLifecycle = (factory) => {
  const onMount = [];
  const onDispose = [];
  const onError = [];
  const componentFactory = factory({
    onMount: (c) => onMount.push(c),
    onDispose: (c) => onDispose.push(c),
    onError: (c) => onError.push(c)
  });
  return (args) => {
    const component = componentFactory(args);
    component.__dispose = onDispose;
    component.__mount = onMount;
    component.__error = onError;
    return component;
  };
};
var GApp = {
  /**
   * 
   * @param {(args: Record<string,unknown>) => Component} component 
   * @param {string} name 
   */
  registerComponent(component, name) {
    if (!component.name && !name) {
      throw new Error('component can be registered because is anonymous. Probably is the result of an high-order function call. In this case, explicitly pass a name as argument of the "registerComponent"');
    }
    Component.__register.set(
      name ? name : component.name,
      component
    );
    return this;
  },
  /**
   * 
   * @param {Component} component 
   * @param {HTMLElement} root
   */
  createRoot(component, root) {
    root.append(...component.render({ tree: [], args: [], refToArgs: [], idx: 0 }));
    return this;
  }
};
export {
  $effect,
  $ref,
  $signal,
  $watcher,
  Component,
  Effect,
  GApp,
  Signal,
  createContext,
  createRoot,
  css,
  html,
  useLifecycle
};
//# sourceMappingURL=gloomjs.js.map
