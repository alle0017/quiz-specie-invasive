{
  "version": 3,
  "sources": ["../../gloomjs/core/reactivity/list.js", "../../gloomjs/core/reactivity/signal.js", "../../gloomjs/core/template/component-parser.js", "../../gloomjs/core/template/dom.js", "../../gloomjs/core/template/component.js", "../../gloomjs/core/template/typeguard.js", "../../gloomjs/core/reactivity/effect.js", "../../gloomjs/core/css/index.js", "../../gloomjs/core/index.js"],
  "sourcesContent": ["/**\n * @template T\n * @param {T} value \n * @returns {ListNode<T>}\n */\nconst createNode = value =>{\n      return {\n            prev: null,\n            next: null,\n            value,\n      }\n}\n/**\n * @template T\n * @param {T} value \n * @param {ListRoot<T>} list \n */\nexport const append = (list, value) => {\n      const node = createNode(value);\n      \n      if( !list.head ){\n            list.head = node;\n      }else{\n            list.head.prev = node;\n            node.next = list.head;\n            list.head = node;\n      }\n}\n\n/**\n * @template T\n * @param {ListRoot<T>} list \n * @param {ListNode<T>} node \n * @returns {T}\n */\nexport const remove = (list, node) => {\n      if( !node.prev ){\n            list.head = node.next;\n      }else{\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n      }\n      return node.value;\n}", "import * as List from \"./list.js\";\nimport is from \"../template/typeguard.js\";\nimport Effect from \"./effect.js\";\n\n/**\n * @template T\n */\nexport default class Signal {\n\n      /**\n       * @type {ListRoot<Subscriber>}\n       */\n      #subs = {\n            head: null,\n      };\n\n      /**\n       * @type {T}\n       */\n      #value;\n\n      get value(){\n            return this.#value;\n      }\n\n      set value( value ){\n\n\n\n            if( value == this.#value && typeof value !== 'object' )\n                  return;\n\n\n            // update the component\n            if( is.Component( this.#value ) ){\n                  if( is.Component( value ) && this.#value.isEqualTo( value ) ){\n                        this.#value.update( ...value.args );\n                  }else{      \n                        \n                        this.#value.dispose();\n                        this.#value = value;\n                  }\n            }else if( is.ComponentList( this.#value ) ){\n\n                  if( is.ComponentList( value ) ){\n\n                        const minLen = this.#value.length > value.length ? \n                              value.length : \n                              this.#value.length;\n\n                        for( let i = 0; i < minLen; i++ ){\n                              if( this.#value[i].isEqualTo( value[i] ) ){\n                                    this.#value[i].update( ...value[i].args );\n                              }else{\n                                    this.#value[i].dispose();\n                                    this.#value[i] = value[i];\n                              }\n                        }\n\n                        if( minLen == value.length ){\n                              for( let i = minLen; i < this.#value.length; i++ ){\n                                    this.#value[i].dispose();\n                              }  \n\n                              this.#value.splice( minLen, this.#value.length - minLen );\n                        }else{\n                              this.#value.push( ...value.slice( minLen ) );\n                        }\n\n\n                  }else{    \n                        for( let i = 0; i < this.#value.length; i++ ){\n                              this.#value[i].dispose();\n                        }  \n                        this.#value = value;\n                  }\n            }else{\n                  this.#value = value;\n            }\n\n            this.#notifyAll();\n      }\n\n\n      #notifyAll(){\n\n            let curr = this.#subs.head;\n\n            while( curr ){\n                  curr.value.update();\n                  curr = curr.next;\n            }\n\n      }\n\n      /**\n       * \n       * @param {T} value \n       */\n      constructor( value ){\n            this.#value = value;\n      }\n\n      /**\n       * return the function used to unsubscribe the subscription\n       * @param {ReactiveRef} ref \n       */\n      subscribe( ref ){\n\n\n            if( ref.isComponent ){\n                  const desc = /**@type {ComponentRef} */(ref);\n\n                  // can be only a component (not even a list of components)\n                  List.append(\n                        this.#subs,{\n                              update: () => {\n                  \n                                    if( is.ComponentList( this.#value ) ){\n            \n                                          const tree = [];\n            \n                                          for( let i = 0; i < this.#value.length; i++ ){\n                                                tree.push( ...this.#value[i].render({ args: [], tree: [], refToArgs: [], idx: 0, }) );\n                                          }\n            \n                                          desc.root.after(...tree);\n                                    }else if( is.Component( this.#value ) ){\n      \n                                          desc.root.after(\n                                                ...this.#value.render({ args: [], tree: [], refToArgs: [], idx: 0, })\n                                          );\n                                    }\n                              }\n                        }\n                  )\n            }else{\n                  const desc = /**@type {SimpleRef}*/(ref);\n                  List.append(\n                        this.#subs, {\n                              update: ()=> {\n                                    if( desc.isTextNode ){\n                                          desc.root.textContent = /**@type {string}*/(this.#value);\n                                    }else if( desc.attributeValue ){\n                                          /**@type {HTMLElement}*/(desc\n                                          .root)\n                                          .setAttribute( \n                                                desc.attribute,  \n                                                /**@type {string}*/(this.#value) \n                                          );\n                                    }else{\n                                          const node = document.createElement( /**@type {string}*/(this.#value) );\n\n                                          desc.root.replaceWith( node );\n                                          desc.root = node;\n                                    }\n                              }\n                        }\n                  )\n            }\n\n            const ticket = this.#subs.head;\n\n            return () => List.remove( this.#subs, ticket );\n      }\n\n      /**\n       * return the function used to unsubscribe the subscription\n       * @param {Subscriber} effect\n       */\n      subscribeEffect( effect ){\n            List.append(\n                  this.#subs, \n                  effect\n            );\n            const ticket = this.#subs.head;\n\n            return () => List.remove( this.#subs, ticket );\n      }\n\n      /**\n       * create an Effect that returns:\n       * - the value returned by the callback invoked on the state of the signal if the signal value is not an array\n       * - a list of values, returned by calling the callback on each element of the state, if the state is an array\n       * the same effect can be achieved by using an effect in combination with the map function\n       * @example\n       * ```javascript\n       * const list = $signal([]);\n       * list.map( \n       *     (v,i) => TodoItem({ description: v, onDelete: () => onDelete(i) }) \n       * )\n       * // is equal to\n       * const renderedList = $effect(\n       *    () => list.value.map((v,i) => TodoItem({ description: v, onDelete: () => onDelete(i) }) ),\n       *    list\n       * )\n       * ```\n       * @template V\n       * @param {T extends Array<infer K> ? (v: K, index: number) => V : (v: T) => V } callback \n       */\n      map( callback ){\n            \n            return new Effect(\n                  () =>{ \n\n                        if( this.#value instanceof Array ){\n                              const res = [];\n\n                              for( let i = 0; i < this.#value.length; i++){\n                                    res.push( callback( this.#value[i], i ) )\n                              }\n                              return res;\n                        }else{\n                              //@ts-ignore\n                              return callback( this.#value )\n                        }\n                  },\n                  this,\n            )\n            \n      }\n}\n", "export default class ComponentParser {\n\n      /**\n       * it starts with a strange sequence for regular text. This is done for \n       * the parsing stage, to check if is regular text or is a keyword. If the compared text is not\n       * this keyword, the check should end in maximum 4 characters.\n       * @readonly\n       */\n      static #pointerToReactive = '£:_--pRiVaTe__REACTIVE_PTR__v0\\.0\\/2024£';\n\n      /**\n       * @readonly\n       */\n      static #tagRegex = new RegExp(`<\\\\s*(${this.#pointerToReactive}|([a-zA-Z][a-zA-Z0-9-]*))(\\\\s+(${this.#pointerToReactive}|@?[a-zA-Z_:][a-zA-Z0-9_.:-]*)(\\\\s*=\\\\s*(?:\"[^\"]*\"|'[^']*'|[^\\\\s>]*))?)*\\\\s*\\/?>`);\n      /**\n       * @readonly\n       */\n      static #tagAttrRegex = new RegExp(`((${this.#pointerToReactive})|@?[a-zA-Z_:][a-zA-Z0-9_\\.:-]*)\\\\s*=\\\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\\\s>]*))|([a-zA-Z_:][a-zA-Z0-9_.:-]*)`, 'g');\n      /**\n       * @readonly\n       */\n      static #tagNameRegex = new RegExp(`<\\\\s*(${this.#pointerToReactive}|([a-zA-Z][a-zA-Z0-9-]*))`);\n      /**\n       * @readonly\n       */\n      static #closingTagRegex = /<\\/\\s*[a-zA-Z][a-zA-Z0-9-]*\\s*>/;\n      /**\n       * @readonly\n       */\n      static #selfClosingTagRegex = /\\s*\\/>/;\n\n      static get pointerToReactive(){\n            return this.#pointerToReactive;\n      }\n\n      /**\n       * is guaranteed that if isTag is true, it returns 1 and only 1 Tree Node\n       * @param {Readonly<string>} slice \n       * @returns {{ tree: Tree, isTag: boolean }}\n       */\n      static #parsePossibleTag( slice  ){\n\n            const check = slice.match( ComponentParser.#tagRegex );\n\n            if( !check || check.index !== 0 ){\n                  return {\n                        isTag: false,\n                        tree: null\n                  };\n            }\n\n            /**\n             * @type {[string, string][]}\n             */\n            const attributes = [];\n            // get the tag type\n            const tagName = slice.match( ComponentParser.#tagNameRegex )[0].replace('<', '');\n            // get attributes=\"value\", or, if the match returns nul, pass empty array \n            // it also removes the tag name, to avoid the\n            // case where the tag name is considered as an attribute\n            const attribNameAndVal = slice.replace( new RegExp(`(${tagName})`), '' ).match( ComponentParser.#tagAttrRegex ) || [];\n            let numOfInterpolations = 0;\n\n            if( tagName == ComponentParser.#pointerToReactive ){\n                  numOfInterpolations++;\n            }\n\n            for( let i = 0; i < attribNameAndVal.length; i++ ){\n\n                  let [name, value] = attribNameAndVal[i].split( '=' );\n\n                  \n                  if( value && ( value[0] == '\\'' || value[0] == '\"' ) ){\n                        value = value.slice( 1, value.length - 1 );\n                  }\n\n                  if( name == ComponentParser.#pointerToReactive ){\n                        throw new DOMException('component cannot use interpolated attribute\\'s names');\n                  }\n\n                  if( value == ComponentParser.#pointerToReactive ){\n                        numOfInterpolations++;\n                  }\n\n                  attributes.push(\n                        [name, value]\n                  );\n            }\n\n            return {\n                  isTag: true,\n                  tree: {\n                        isTextNode: false,\n                        attributes,\n                        children: [],\n                        tagName,\n                        reference: null,\n                        numOfInterpolations,\n                  }\n            };\n      }\n\n\n      /**\n       * \n       * @param {Readonly<string>} string \n       */\n      static #compareWithReactivePointer( string ){\n            const keyword = ComponentParser.#pointerToReactive;\n            let j = 1;\n\n            while( j < keyword.length ){\n                  if( keyword[j] !== string[j] )\n                        return false;\n                  j++;\n            }\n\n            return true;\n      }\n\n\n      /**\n       * @throws {ReferenceError} if the pointer keyword is used inside the template\n       * @throws {DOMException} if the parsing phase notice an error. some scenarios are when a tag is closed but is never opened\n       * @param {Readonly<string>} template\n       * @returns {Tree[]}\n       */\n      static createHtmlTree( template ){\n\n            /**\n             * @type {Tree}\n             */\n            const root = {\n                  tagName: null,\n                  attributes: null,\n                  children: [],\n                  reference: null,\n                  isTextNode: false,\n                  numOfInterpolations: 0,\n            };\n\n            \n            /**\n             * @type {Stack<Tree>}\n             */\n            const stack = [ root ];\n\n\n            let text = '';\n\n            for( let i = 0; i < template.length; i++ ){\n\n                  if( template[i] == ComponentParser.#pointerToReactive[0] && this.#compareWithReactivePointer( template.slice(i) ) ){\n\n                        stack\n                        .at( -1 )\n                        .children\n                        .push(\n                              // the text found before\n                              {\n                                    children: [],\n                                    isTextNode: true,\n                                    tagName: text,\n                                    reference: undefined,\n                                    attributes: [],\n                                    numOfInterpolations: 0,\n                              }, \n                              // the reactive node\n                              {\n                                    children: [],\n                                    isTextNode: true,\n                                    tagName: ComponentParser.#pointerToReactive,\n                                    reference: undefined,\n                                    attributes: [],\n                                    numOfInterpolations: 1,\n                              }\n                        );\n\n                        stack\n                        .at( -1 )\n                        .numOfInterpolations++;\n\n                        text = '';\n\n                        i += ComponentParser.#pointerToReactive.length - 1;\n\n                        continue;\n                  }\n\n                  if( template[i] == '\\\\' ){\n                        // skip the next character\n                        text += ('\\\\'+ template[ i + 1 ]);\n                        i++;\n                        continue;\n                  }\n\n                  if( template[i] == '<' ){\n                        const last = template.indexOf( '>', i + 1 );\n\n                        if( last >= 0 ){\n                              const tag = template.slice( i, last + 1 );\n\n                              if( tag.match( ComponentParser.#closingTagRegex ) ){\n                                    stack\n                                    .at(-1)\n                                    .children\n                                    .push({\n                                          children: [],\n                                          isTextNode: true,\n                                          tagName: text,\n                                          reference: undefined,\n                                          attributes: [],\n                                          numOfInterpolations: 0,\n                                    });\n                                    text = '';\n                                    // we don't have to parse anything, just pop what was the last opened tag\n                                    const tree = stack.pop();\n\n                                    stack\n                                    .at(-1)\n                                    .numOfInterpolations += tree.numOfInterpolations;\n                                    \n                                    \n                                    if( stack.length < 1 )\n                                          throw new DOMException('Invalid closing tag in template');\n                                    // we already analyzed until last index\n                                    i = last;\n                                    continue;\n                              }\n\n                              const res = this.#parsePossibleTag( tag );\n\n                              if( !res.isTag ){\n                                    text += template[i];\n                                    continue;\n                              }\n\n                              stack\n                              .at( -1 )\n                              .children\n                              .push({\n                                    children: [],\n                                    isTextNode: true,\n                                    tagName: text,\n                                    reference: undefined,\n                                    attributes: [],\n                                    numOfInterpolations: 0,\n                              }, res.tree);\n\n\n                              if( !tag.match( ComponentParser.#selfClosingTagRegex ) ){\n                                    // if it's self closing tag, \n                                    //it doesn't need to be pushed inside the stack\n                                    //pathToReactive.push( stack.at(-1).children.length - 1 );\n                                    stack.push( res.tree );\n                              }else{\n                                    stack\n                                    .at( -1 )\n                                    .numOfInterpolations += res.tree.numOfInterpolations;\n                              }\n\n                              // clean up the already-processed text\n                              text = '';\n\n                              // we already analyzed until last index\n                              i = last;\n\n                              continue;\n                        }\n                  }\n\n                  text += template[i];\n            }\n\n            root\n            .children\n            .push({\n                  children: [],\n                  isTextNode: true,\n                  tagName: text,\n                  reference: undefined,\n                  attributes: [],\n                  numOfInterpolations: 0,\n            });\n\n\n            return root.children;\n      }\n      /**\n       * @param {TemplateStringsArray} strings \n       * @returns {string}\n       */\n      static reduceTemplateStringArray( strings ){\n            return strings.reduce( (p,c) =>{ \n                  if( c.indexOf( ComponentParser.#pointerToReactive ) >= 0 ){\n                        throw new ReferenceError( \n                              ComponentParser.#pointerToReactive +\n                              \" is a private keyword. consider using other words instead or escaping it with codes.\" \n                        );\n                  }\n                  return p + ComponentParser.#pointerToReactive + c;\n            });\n      }\n}", "import is from \"./typeguard.js\";\n/**@import Component from \"./component.js\" */\n/**\n * \n * @param {Tree} leaf \n * @param {string} tagName\n */\nconst cloneElement = ( leaf, tagName ) =>{\n\n      if( leaf.reference && tagName == /**@type {HTMLElement}*/(leaf.reference).tagName ){\n            const node = /**@type {HTMLElement}*/(leaf.reference.cloneNode( false ));\n\n            for( let i = 0; i < node.attributes.length; i++ ){\n                  node.setAttribute( node.attributes[i][0], '' );\n            }\n            return node;\n      }\n\n      leaf.reference = document.createElement( tagName );\n      return leaf.reference;\n}\n/**\n * \n * @param {Tree} leaf \n * @param {string} text\n */\nconst cloneText = ( leaf, text )=> {\n      if( leaf.reference ){\n            const textNode = leaf.reference.cloneNode( false );\n            \n            textNode.textContent = text;\n            return /**@type {Text}*/(textNode);\n      }\n\n      leaf.reference = document.createTextNode( text );\n      return leaf.reference;\n}\n\n/**\n * create a straightforward dom element, that could be html element or\n * text element.\n * @param {string} name \n * @param {Tree} leaf \n */\nexport const createElement = ( name, leaf ) => {\n      if( leaf.isTextNode ){\n            return {\n                  tag: [cloneText( leaf, name )],\n                  needAttributes: false,\n                  skipAttributes: false,\n            };\n      }\n      return {\n            tag: [cloneElement( leaf, name )],\n            needAttributes: true,\n            skipAttributes: false,\n      };\n}\n// TODO add the reference (refToArgs) when the component is created\n/**\n* \n* @param {Component} component \n* @param {Tree} leaf \n* @param {unknown[]} args\n* @param {number} refIdx represents the index used by refToArgs\n* @param {Args[]} refToArgs\n* @returns {RenderingResult}\n*/\nexport const createComponent = ( component, leaf, args, refToArgs, refIdx ) => {\n      return {\n            tag: component.render({ \n                  tree: leaf.children,\n                  args,\n                  refToArgs,\n                  idx: refIdx + 1,\n            }),\n            usedArgs: leaf.numOfInterpolations,\n            needAttributes: false,\n            skipAttributes: false,\n      };\n }\n\n/**\n * @param {Tree} leaf\n * @param {unknown[]} args\n * @param {Component[]} components \n * @param {number} refIdx represents the index used by refToArgs\n * @param {Args[]} refToArgs\n * @returns {RenderingResult}\n */\nexport const createComponentList = ( components, leaf, args, refToArgs, refIdx )=>{\n      const tree = [];\n\n      if( !components.length ){\n            tree.push( document.createTextNode('') );\n\n            return {\n                  tag: tree,\n                  usedArgs: leaf.numOfInterpolations,\n                  needAttributes: false,\n                  skipAttributes: false,\n            }\n      }\n      \n\n      for( let i = 0; i < components.length; i++ ){\n            tree.push( ...components[i].render({\n                  tree: leaf.children,\n                  args,\n                  refToArgs,\n                  idx: refIdx + 1,\n            }));\n      }\n      return {\n            tag: tree,\n            usedArgs: leaf.numOfInterpolations,\n            needAttributes: false,\n            skipAttributes: false,\n      };\n}\n\n/**\n * create an element from any object that is a reference, in some way, to a Reactive\n * @param {Reactive} reactive \n * @param {unknown} value\n * @param {Tree} leaf\n * @param {unknown[]} args\n * @param {number} idx\n * @param {number} refIdx represents the index used by refToArgs\n * @param {Args[]} refToArgs\n * @returns {{ res: RenderingResult, unsubscribe: () => void }}\n */\nexport const createFromAnyReactive = ( reactive, value, leaf, args, idx, refToArgs, refIdx )=>{\n\n      if( is.Component( value ) ){\n            const res = createComponent( value, leaf, args.slice( idx, leaf.numOfInterpolations + 1 ), refToArgs, refIdx );\n            const root = document.createTextNode('');            \n            const unsubscribe = reactive.subscribe({\n                  isComponent: true,\n                  root: root,\n            });\n\n            res.tag.unshift(\n                  /**\n                   * @type {any}\n                   */\n                  (root) \n            );\n\n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isComponent: true,\n                        root: [root],\n                        isSubscription: true,\n                        subscription: null,\n                        children: leaf,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(root);\n            }\n\n            refIdx++;\n\n\n            return {\n                  res,\n                  unsubscribe,\n            }; \n      }else if( is.ComponentList( value ) ){\n            const res = createComponentList( value, leaf, args.slice( idx, leaf.numOfInterpolations + 1 ), refToArgs, refIdx );\n            const root = document.createTextNode('');\n\n            res.tag.unshift( \n                  /**\n                  * @type {any} \n                  * otherwise it will throw error because is not HTMLElement and Text\n                  */\n                  (root) \n            );\n\n            const unsubscribe = reactive.subscribe({\n                  isComponent: true,\n                  root: root,\n            });\n\n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isComponent: true,\n                        root: [root],\n                        isSubscription: true,\n                        subscription: null,\n                        children: leaf,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(root);\n            }\n\n            refIdx++;\n\n\n            return {\n                  res,\n                  unsubscribe,\n            };\n      }else if( leaf.isTextNode ){\n            const ref = document.createTextNode( /**@type {string}*/(value) );\n\n\n            const unsubscribe = reactive.subscribe({\n                  isComponent: false,\n                  root: ref, \n                  tagName: false,\n                  attributeValue: false,\n                  attribute: null,\n                  isTextNode: true,\n            });\n\n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isTextNode: true,\n                        root: [ref],\n                        isSubscription: true,\n                        subscription: null,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(ref);\n            }\n\n            refIdx++;\n\n            return {\n                  res: {\n                        usedArgs: 1,\n                        needAttributes: false,\n                        tag: [ref],\n                        skipAttributes: false,\n                  },\n                  unsubscribe,\n            }\n      }else{\n            const ref = document.createElement( /**@type {string}*/(value) );\n            \n            const unsubscribe = reactive.subscribe({\n                  isComponent: false,\n                  root: ref, \n                  tagName: true,\n                  attributeValue: false,\n                  attribute: null,\n                  isTextNode: false,\n            });\n            \n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isTagName: true,\n                        root: [ref],\n                        isSubscription: true,\n                        subscription: null,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(ref);\n            }\n\n            refIdx++;\n\n\n            return {\n                  res: { \n                        usedArgs: 1,\n                        needAttributes: true,\n                        tag: [ref],\n                        skipAttributes: false,\n                  },\n                  unsubscribe,\n            }\n      }\n}\n", "import ComponentParser from './component-parser.js';\nimport Effect from '../reactivity/effect.js';\nimport Signal from '../reactivity/signal.js';\nimport * as dom from './dom.js';\nimport * as List from '../reactivity/list.js';\n\n/**\n* true if the leaf is `<Children/>`\n* @param {Tree} leaf \n* @param {unknown} arg \n* @returns {boolean} \n*/\nconst isChildrenLeaf = ( leaf, arg ) => Boolean( leaf.tagName == 'Children' || ( leaf.tagName == ComponentParser.pointerToReactive && typeof arg == 'string' && arg == 'Children' ) );\n/**\n* check if object is a Ref\n* @param {unknown} value \n* @returns {value is Ref<HTMLElement>}\n*/\nconst isRef = value => value && typeof value == 'object' && '__isRef__' in value && value.__isRef__ && 'element' in value && !Boolean(value.element)\n\n/**\n* check if object is a Ref\n* @param {unknown} value \n* @returns {value is ScopedCss}\n*/\nconst isScopedCss = value => value && typeof value == 'object' && '__css__Key' in value && typeof value.__css__Key == 'string'\n/**\n * check if object is a component list\n * note, it only checks the first and the last elements, \n * ### if the first and the last elements are a Component, **all** the list will be rendered as a component\n * @param {unknown} value \n * @returns {value is Component[]}\n */\nconst isComponentList = value => typeof value == 'object' && value instanceof Array && (value[0] instanceof Component || value.length <= 0);\n/**\n * @param {unknown} s \n * @param {unknown} o \n */\nconst areEquals = ( s, o ) => {\n      if( s == o )\n            return true;\n\n      let flag = true;\n\n      if( \n            typeof s == 'object' && \n            typeof o == 'object' && \n            !(s instanceof Component) &&\n            !(o instanceof Component) && \n            !isComponentList(s) &&\n            !isComponentList(o) ){\n\n            Object.entries( o ).every( ( [k,v] ) => {\n                  if( !s[k] && s[k] != v )\n                        flag = false;\n                  flag = areEquals( s[k], v );\n                  return flag;\n            });\n      }else{\n            flag = false;\n      }\n      return flag;\n}\n/**\n * @implements {Drawable}\n */\nexport default class Component {\n\n      /**\n       * @type {Map<string,{ tree: Tree[] }>}\n       */\n      static #cachedTrees = new Map();\n\n      /**\n       * @type {Map<string, (args: Record<string,unknown>) => Component>}\n       */\n      static __register = new Map();\n\n      static #id = 0;;\n\n      #pid;\n\n      /**\n       * @type {Array<string>}\n       */\n      #cssKeys = [];\n\n      /**\n       * @readonly\n       * @type {Tree[]}\n       */\n      #tree;\n\n      /**\n       * @type {Array<HTMLElement|Text>}\n       */\n      #root;\n\n      /**\n       * @type {unknown[]}\n       */\n      #args = [];\n\n      /**\n       * @type {Args[]}\n       */\n      #refToArgs = [];\n\n      /**\n       * @type {ListRoot<()=>void>}\n       */\n      #subs = {\n            head: null,\n      };\n\n      /**\n       * @type {Array<()=>void>}\n       */\n      __dispose = [];\n      /**\n       * @type {Array<()=>void>}\n       */\n      __mount = [];\n      /**\n       * @type {Array<(e: Error)=>void>}\n       */\n      __error = [];\n\n      /**\n       * @type {Readonly<unknown[]>}\n       */\n      get args(){\n            return this.#args;\n      }\n\n      /**\n       * @param {TemplateStringsArray} html\n       * @param {unknown[]} args\n       * @hideconstructor\n       */\n      constructor( html, ...args ) {\n            const template = ComponentParser.reduceTemplateStringArray( html );\n            const key = template.replaceAll(/\\s+/ig, '');\n\n            if( Component.#cachedTrees.has( key ) ) {\n                  this.#tree = Component.#cachedTrees.get( key ).tree;\n            }else{\n                  this.#tree = ComponentParser.createHtmlTree( template );\n                  Component.#cachedTrees.set( key, {\n                        tree: this.#tree\n                  });\n            }\n\n            this.#pid = Component.#id++;\n            this.#refToArgs = new Array( args.length );\n            this.#args = args;\n      }\n\n      /**\n       * returns the html instance of the component passed as input\n       * @param {Readonly<Tree>} leaf\n       * @param {unknown[]} args\n       * @param {number} idx \n       * @param {number} refIdx represents the index used by refToArgs\n       * @param {Args[]} refToArgs\n       */\n      #createRegisteredElement( leaf, args, idx, refToArgs, refIdx){\n            /**\n             * @type {Record<string,unknown>}\n             */\n            const props = {};\n            // prop keys that are ${...}\n            const boundKeys = [];\n            // if an arg is used, then we add it to skip it during the next update\n            let numOfArgs = 0;\n\n            for( let i = 0; i < leaf.attributes.length; i++ ){\n                  const value = leaf.attributes[i][1];\n\n                  if( typeof value == 'string' && value.indexOf( ComponentParser.pointerToReactive ) >= 0 ){\n                        props[leaf.attributes[i][0]] = args[idx + numOfArgs];\n                        boundKeys.push(leaf.attributes[i][0])\n                        numOfArgs++;\n                  }else{\n                        props[leaf.attributes[i][0]] = leaf.attributes[i][1];\n                  }\n            }\n\n            const component = Component.__register.get( leaf.tagName )( props );\n            let root;\n            /**\n             * @type {RenderingResult}\n             */\n            let res;\n\n            if( component instanceof Component ){\n                  res = dom.createComponent( \n                        component, \n                        leaf, \n                        numOfArgs < leaf.numOfInterpolations? \n                              args.slice( idx + numOfArgs, idx + leaf.numOfInterpolations ):\n                              [], \n                        refToArgs, \n                        refIdx + numOfArgs \n                  );\n                  root = document.createTextNode('');\n\n                  res.tag[0].before( root );\n\n                  res.usedArgs = \n                        res.usedArgs > numOfArgs? \n                              res.usedArgs - numOfArgs:\n                              numOfArgs;\n                              \n                  res.skipAttributes = true;\n            }else if( isComponentList( component ) ){\n\n                  res = dom.createComponentList( \n                        component, \n                        leaf, \n                        numOfArgs < leaf.numOfInterpolations? \n                              args.slice( idx + numOfArgs, idx + leaf.numOfInterpolations ):\n                              [], \n                        refToArgs, \n                        refIdx + numOfArgs \n                  );\n                  root = document.createTextNode('');\n\n                  res.tag[0].before( root );\n\n                  res.usedArgs = \n                        res.usedArgs > numOfArgs? \n                              res.usedArgs - numOfArgs:\n                              numOfArgs;\n                  res.skipAttributes = true;\n                  /*res = dom.createComponentList( component, leaf, args.slice( idx + numOfArgs, idx + leaf.numOfInterpolations ), refToArgs, refIdx + numOfArgs );\n                  root = document.createTextNode('');\n\n                  res.usedArgs -= numOfArgs;\n                  res.tag[0].before( root );*/\n            }else{\n\n                  res = {\n                        ...dom.createElement( leaf.tagName, leaf ),\n                        needAttributes: false,\n                        usedArgs: numOfArgs,\n                        // skip the \"skipping-phase\"\n                        skipAttributes: true,\n                  };\n                  root = res.tag[0];\n            }\n\n            //res.usedArgs += numOfArgs;    \n\n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isRegisteredComponent: true,\n                        root: [root],\n                        props,\n                        children: leaf,\n                        component: {\n                              name: leaf.tagName,\n                              instance: component,\n                        },\n                        boundKeys,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(root);\n            }\n\n            return res;\n      }\n\n      /**\n       * returns the html instance of the component passed as input\n       * @param {Readonly<Tree>} leaf\n       * @param {unknown[]} args\n       * @param {number} idx \n       * @param {number} refIdx represents the index used by refToArgs\n       * @param {Args[]} refToArgs\n       * @returns {RenderingResult}\n       */\n      #createElement( leaf, args, idx, refToArgs, refIdx ) {\n\n\n            if( Component.__register.has( leaf.tagName ) ){\n                  return this.#createRegisteredElement( leaf, args, idx, refToArgs, refIdx );\n            }\n\n            const value = args[idx];\n\n            if( leaf.tagName !== ComponentParser.pointerToReactive ){\n\n                  return {\n                        ...dom.createElement( leaf.tagName, leaf ),\n                        usedArgs: 0,\n                  };\n            }\n\n            if( value instanceof Component ){\n                  \n                  const res = dom.createComponent( value, leaf, args.slice( idx + 1, leaf.numOfInterpolations + 1 ), refToArgs, refIdx );\n                  const root = document.createTextNode('');\n\n                  res.tag[0].before( root );\n                  //@ts-ignore\n                  res.tag.unshift( root );\n\n                  if( !refToArgs[ refIdx ] ){\n                        refToArgs[ refIdx ] = {\n                              isComponent: true,\n                              root: [root],\n                              children: leaf,\n                        };\n                  }else{\n                        refToArgs[ refIdx ].root.push(root);\n                  }\n                  return res;\n            }else if( isComponentList( value ) ){\n                  const res = dom.createComponentList( value, leaf, args.slice( idx + 1, leaf.numOfInterpolations + 1 ), refToArgs, refIdx );\n                  const root = document.createTextNode('');\n\n                  res.tag[0].before( root );\n                  //@ts-ignore\n                  res.tag.unshift( root );\n\n                  if( !refToArgs[ refIdx ] ){\n                        refToArgs[ refIdx ] = {\n                              isComponent: true,\n                              root: [root],\n                              children: leaf,\n                        };\n                  }else{\n                        refToArgs[ refIdx ].root.push(root);\n                  }\n                  return res;\n            }else if( value instanceof Signal ){\n                  const { unsubscribe, res } = dom.createFromAnyReactive( value, value.value, leaf, args, idx, refToArgs, refIdx );\n                  List.append(\n                        this.#subs,\n                        unsubscribe,\n                  );\n\n                  if( !refToArgs[refIdx].subscription ){\n                        refToArgs[ refIdx ].subscription = [this.#subs.head];\n                  }else{\n                        refToArgs[ refIdx ].subscription.push(this.#subs.head);\n                  }\n                  \n                  return res;\n            }else if( value instanceof Effect ){\n                  const { unsubscribe, res } =  dom.createFromAnyReactive( value, value.state, leaf, args, idx, refToArgs, refIdx );\n\n                  List.append(\n                        this.#subs,\n                        unsubscribe,\n                  );\n\n                  if( !refToArgs[refIdx].subscription ){\n                        refToArgs[ refIdx ].subscription = [this.#subs.head];\n                  }else{\n                        refToArgs[ refIdx ].subscription.push(this.#subs.head);\n                  }\n                  return res;\n            }\n\n            const res = dom.createElement( /**@type {string}*/(value), leaf );\n\n            if( !refToArgs[ refIdx ] ){\n                  refToArgs[ refIdx ] = {\n                        isTagName: true,\n                        root: [res.tag[0]],\n                        isTextNode: leaf.isTextNode,\n                  };\n            }else{\n                  refToArgs[ refIdx ].root.push(res.tag[0]);\n            }\n\n            return {\n                  ...res,\n                  usedArgs: 1,\n\n            };\n      }\n\n      /**\n       * \n       * @param {HTMLElement} tag \n       * @param {[string,unknown][]} attributes \n       * @param {unknown[]} args \n       * @param {number} idx \n       * @param {number} refIdx represents the index used by refToArgs\n       * @param {Args[]} refToArgs\n       * @returns {number} \n       */\n      #setAttributes( tag, attributes, args, idx, refToArgs, refIdx ){\n\n            for( let i = 0; i < attributes.length; i++ ){\n\n                  if( attributes[i][1] == ComponentParser.pointerToReactive ){\n\n                        const arg = args[idx];\n\n                        if( arg instanceof Signal ){\n                              tag.setAttribute( attributes[i][0], /**@type {string}*/(arg.value) );\n\n                              const unsubscribe = arg.subscribe({\n                                    isComponent: false,\n                                    attribute: attributes[i][0],\n                                    root: tag,\n                                    attributeValue: true,\n                                    tagName: false,\n                                    isTextNode: false,\n                              });\n\n                              List.append(\n                                    this.#subs,\n                                    unsubscribe,\n                              );\n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          attribute: attributes[i][0],\n                                          root: [tag],\n                                          isAttributeValue: true,\n                                          isSubscription: true, \n                                          subscription: [this.#subs.head],\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                                    refToArgs[refIdx].subscription.push(this.#subs.head);\n                              }\n\n                              \n\n                        }else if( arg instanceof Effect ){\n                              const unsubscribe = arg.subscribe({\n                                    isComponent: false,\n                                    attribute: attributes[i][0],\n                                    root: tag,\n                                    attributeValue: true,\n                                    tagName: false,\n                                    isTextNode: false,\n                              });\n\n                              List.append(\n                                    this.#subs,\n                                    unsubscribe,\n                              );\n\n                              tag.setAttribute( attributes[i][0], /**@type {string}*/(arg.state) );\n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          attribute: attributes[i][0],\n                                          root: [tag],\n                                          isAttributeValue: true,\n                                          isSubscription: true, \n                                          subscription: [this.#subs.head],\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                                    refToArgs[refIdx].subscription.push(this.#subs.head);\n                              }\n                              \n                        }else if( typeof arg == 'function' && attributes[i][0][0] == '@' ){\n                              // attribute is an event\n                              tag.addEventListener( attributes[i][0].slice(1), /**@type {(e)=>void}*/(arg) );\n\n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          attribute: attributes[i][0],\n                                          root: [tag],\n                                          isEvent: true,\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                              }\n\n                        }else if( isRef( arg ) ){\n                              arg.element = tag;\n                              \n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          root: [tag],\n                                          isRef: true,\n                                          ref: arg,\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                              }\n                        }else if( isScopedCss( arg ) ){\n                              this.#cssKeys.push( arg.__css__Key );\n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          root: [tag],\n                                          isCssKey: true,\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                              }\n\n                        }else{\n                              tag.setAttribute( attributes[i][0], /**@type {string}*/(arg) );\n\n                              if( !refToArgs[ refIdx ] ){\n                                    refToArgs[ refIdx ] = {\n                                          attribute: attributes[i][0],\n                                          root: [tag],\n                                          isAttributeValue: true,\n                                    };\n                              }else{\n                                    refToArgs[refIdx].root.push(tag);\n                              }\n                        }\n\n                        idx++;\n                        refIdx++;\n                  }else{\n                        tag.setAttribute( attributes[i][0], /**@type {string}*/(attributes[i][1]) );\n                  }\n            }\n\n            // add all the keys that scopes the components style\n            this.#cssKeys.length && tag.classList.add( ...this.#cssKeys );\n            \n            return idx;\n      }\n\n      /**\n       * \n       * @param {Tree[]} tree \n       * @param {Children} children\n       * @param {unknown[]} args \n       * @param {number} idx \n       * @param {number} refIdx represents the index used by refToArgs\n       * @param {Args[]} refToArgs represent the reference to that links an arg to the actual dom leaf\n       * @throws {DOMException} if a children with attributes/children is found\n       */\n      #createDOMRecursive( tree, children, args, idx, refToArgs, refIdx ) {\n\n            // the list containing the children \n            // of the component who invoked the createDOMRecursive\n            const fatherList = [];\n\n            for( let i = 0; i < tree.length; i++ ){\n                  // current leaf\n                  // used to have type inference with ts\n                  const leaf = tree[ i ];\n\n                  // if the leaf is a placeholder\n                  if( isChildrenLeaf( leaf, args[idx] ) ){\n\n                        if( leaf.children.length > 0 || leaf.attributes.length > 0 ){\n                              throw new DOMException(\"'Children' tag must be self-closing without attributes\")\n                        }\n\n                        // children.args are the args of the component which contains the \n                        // custom component we are rendering now\n\n                        // render the children of a custom component\n                        // don't change children.idx to be ab le to use \n                        // multiple children\n                        const { childList: list, idx: _ } = this.#createDOMRecursive( children.tree, {\n                              tree: [],\n                              args: [],\n                              refToArgs: [],\n                              idx: 0,                             \n                        }, children.args, 0, children.refToArgs, children.idx );\n\n\n                        // we DON'T want to change children.idx\n                        // because it can be reused later for another <Children/> element\n\n                        // and then add it as normal tags\n                        fatherList.push( ...list );\n                        continue;\n                  }\n\n                  const { \n                        tag: tagList, \n                        needAttributes, \n                        usedArgs,\n                        skipAttributes\n                  } = this.#createElement( leaf, args, idx, refToArgs, refIdx );\n\n                  fatherList.push( ...tagList );\n\n                  idx += usedArgs;\n                  refIdx += usedArgs;\n\n\n                  if( needAttributes ){\n                        const usedArgs = this.#setAttributes( \n                              /**@type {HTMLElement}*/(tagList[0]), \n                              leaf.attributes, \n                              args, \n                              idx,\n                              refToArgs,\n                              refIdx\n                        );\n\n                        // number of attributes that require \n                        // args\n                        refIdx += (usedArgs - idx);\n                        idx = usedArgs;\n                  }else if( !skipAttributes ){\n                        for( let j = 0; j < leaf.attributes.length; j++ ){\n                              if( leaf.attributes[j][1] == ComponentParser.pointerToReactive ){\n\n                                    // we are not interested in the root here\n                                    // just skip checking\n                                    refToArgs[refIdx] = {\n                                          root: [],\n                                          attribute: leaf.attributes[j][0],\n                                          isAttributeValue: true,\n                                    };\n\n                                    idx++;\n                                    refIdx++;\n                              }\n                        }\n                  }\n\n                  // if the tag have children,\n                  // but the tagList is > 1, than is a custom component,\n                  // so we already rendered the children\n                  if( tagList.length == 1 ){\n                        // we only have one component\n\n                        if( leaf.children.length ){\n                              const { childList, idx: index } = this.#createDOMRecursive( leaf.children, children, args, idx, refToArgs, refIdx );\n\n                              refIdx += (index - idx);\n                              /**@type {HTMLElement}*/(tagList[0]).append(...childList);\n                              idx = index;\n                        }\n                  }\n            }\n\n\n            return {\n                  childList: fatherList,\n                  idx\n            };\n      }\n\n      /**\n       * removes subscriptions, refs (etc...) from the args\n       * @param {number} i\n       */\n      #clearReferences( i ){\n            if( this.#refToArgs[i].isSubscription ){\n                  // if it fails,\n                  // the problem could the fact that the subscription is not linked\n                  // watch dom.createFromAnyReactive for debugging purposes\n\n                  const subs = this.#refToArgs[i].subscription;\n                  for( let j = 0; j < subs.length; j++ ){\n                        subs[j].value();\n                        List.remove( \n                              this.#subs, \n                              subs[j] \n                        );\n                  }\n                  \n            }else if( this.#refToArgs[i].isRef ){\n                  // free the reference\n                  this.#refToArgs[i].ref.element = null;\n            }else if( this.#refToArgs[i].isEvent ){\n\n                  const roots = this.#refToArgs[i].root;\n                  for( let j = 0; j < roots.length; j++ ){\n                        roots[j].removeEventListener( \n                              this.#refToArgs[i].attribute.slice(1),\n                              /**@type {(e: Event)=>void}*/(this.#args[i])\n                        );\n                  }\n            }\n\n      }\n      /**\n       * if the old arg is different from the new arg, it updates it and mark\n       * the corresponding refToArgs as dirty, so that the fw \n       * now where it needs to update.\n       * @param  {...unknown} args \n       * @returns {number[]}\n       */\n      #updateInternalState( ...args ){\n\n            const toUpdate = [];\n\n            for( let i = 0; i < args.length; i++ ){\n                  const self = this.#args[i];\n                  const other = args[i];\n\n\n                  if( this.#refToArgs[i] && this.#refToArgs[i].isRegisteredComponent ){\n                        // skip the component used properties\n\n                        for( let j = 0; j < this.#refToArgs[i].boundKeys.length; j++ ){\n                              this.#refToArgs[i].props[this.#refToArgs[i].boundKeys[j]] = args[ i + j ];\n                        }\n\n                        const self = this.#refToArgs[i].component.instance;\n                        const other = Component.__register.get( this.#refToArgs[i].component.name )( this.#refToArgs[i].props );\n\n\n                        if( self.isEqualTo( other ) ){\n                              self.update( this.#refToArgs[i].props );\n                        }else{\n                              self.dispose();\n                              this.#refToArgs[i].component.instance = other;\n                        }\n                        i += this.#refToArgs[i].boundKeys.length;\n                  }\n\n                  if( areEquals( self, other ) ){\n                        const roots = this.#refToArgs[i].root;\n                        if( this.#refToArgs[i].isAttributeValue ){\n                              \n                              let value = self;\n\n                              if(  self instanceof Effect ){\n                                    value = self.state;\n                              }else if( self instanceof Signal ){\n                                    value = self.value;\n                              }\n                              for( let j = 0; j < roots.length; j++ ){\n                                    /**@type {HTMLElement}*/(roots[j]).setAttribute( \n                                          this.#refToArgs[i].attribute,\n                                          /**@type {string}*/(value)\n                                    );\n                              }\n                        }\n                        continue;\n                  }\n\n                  toUpdate.push(i);\n\n\n                  if( self instanceof Component && other instanceof Component ){\n\n                        if( self.isEqualTo( other ) ){\n                              self.update( ...other.#args );\n                        }else{\n                              self.dispose();\n                              this.#args[i] = other;\n                        }\n                  }else if( isComponentList( self ) && isComponentList( other ) ){\n                        const minLen = other.length < self.length ?\n                              other.length : \n                              self.length;\n\n                        for( let j = 0; j < minLen; j++ ){\n                              const s = self[j];\n                              const o = other[j];\n\n                              if( !(s instanceof Component) || !(o instanceof Component) )\n                                    throw new TypeError( \"array of components must be homogeneous\" );\n\n                              if( s.isEqualTo( o ) ){\n                                    s.update( ...o.#args );\n                              }else{\n                                    s.dispose();\n                                    self[j] = o;\n                              }\n                        }\n\n                        if( minLen == other.length ){\n\n                              for( let j = minLen; j < self.length; j++ ){\n                                    const s = self[j];       \n                                    if( !(s instanceof Component) )\n                                          throw new TypeError( \"array of components must be homogeneous\" );\n                                    s.dispose();\n                              }\n\n                              self.length = minLen;\n                        }else{\n                              for( let j = minLen; j < other.length; j++ ){\n                                    const o = other[j];       \n                                    if( !(o instanceof Component) )\n                                          throw new TypeError( \"array of components must be homogeneous\" );\n                                    self.push( o );\n                              }\n                        }\n                  }else{\n                        if( other instanceof Component ){\n                              // delete the subscription\n                              this.#clearReferences( i );\n\n                              this.#refToArgs[i] = { \n                                    isComponent: true,\n                                    root: this.#refToArgs[i].root,\n                              }\n                        }else if( isComponentList( other ) ){\n                              // delete the subscription\n                              this.#clearReferences( i );\n\n                              this.#refToArgs[i] = {\n                                    isComponent: true,\n                                    root: this.#refToArgs[i].root,\n                              }\n                        }else if( other instanceof Signal || other instanceof Effect ){\n                              // delete the subscription\n                              this.#clearReferences( i );\n\n                              this.#refToArgs[i].isSubscription = true;\n                              this.#refToArgs[i].subscription = [];\n\n                              for( let j = 0; j < this.#refToArgs[i].root.length; j++ ){\n                                    const unsubscribe = other.subscribe({\n                                          isComponent: this.#refToArgs[i].isComponent,\n                                          root: this.#refToArgs[i].root[i],\n                                          tagName: this.#refToArgs[i].isTagName,\n                                          attributeValue: this.#refToArgs[i].isAttributeValue,\n                                          attribute: this.#refToArgs[i].attribute,\n                                          isTextNode: this.#refToArgs[i].isTextNode,\n                                    });\n\n                                    List.append(\n                                          this.#subs,\n                                          unsubscribe\n                                    );\n\n                                    this.#refToArgs[i].subscription.push( this.#subs.head );\n                              }\n                        }else if( isRef( other ) ){\n\n                              this.#clearReferences( i );\n                              this.#refToArgs[i] = {\n                                    isRef: true,\n                                    root: this.#refToArgs[i].root,\n                                    ref: other,\n                              };\n                        }else if( \n                              this.#refToArgs[i].isTextNode || \n                              this.#refToArgs[i].isTagName || \n                              this.#refToArgs[i].isAttributeValue || \n                              this.#refToArgs[i].isEvent\n                        ){\n                              this.#clearReferences( i );\n                        }else if( !this.#refToArgs[i].isCssKey ){\n                              throw new TypeError(\"no match for the type you are interpolating\");\n                        }\n                        \n                        this.#args[i] = other;\n                  }\n            }\n\n            return toUpdate;\n      }\n\n      /**\n       * update every arg that is not a component.\n       * this is done to not cause precedence problems \n       * with children\n       * @param {readonly number[]} toUpdate \n       */\n      #updateAttributes( toUpdate ){\n            const components = [];\n\n\n            for( let j = 0; j < toUpdate.length; j++ ){\n\n\n                  const i = toUpdate[j];\n                  const self = this.#args[i];\n                  const roots = this.#refToArgs[i].root;\n                  let value = self;\n\n\n                  if(  self instanceof Effect ){\n                        value = self.state;\n                  }else if( self instanceof Signal ){\n                        value = self.value;\n                  }\n\n                  if( this.#refToArgs[i].isComponent ){\n                        components.push( i );\n                  }else if( this.#refToArgs[i].isEvent ){\n                        for( let j = 0; j < roots.length; j++ ){\n                              roots[j].addEventListener( \n                                    this.#refToArgs[i].attribute.slice(1), \n                                    /**@type {(e: Event)=>void}*/(self) \n                              );\n                        }\n\n                  }else if( this.#refToArgs[i].isAttributeValue ){\n                        for( let j = 0; j < roots.length; j++ ){\n                              /**@type {HTMLElement}*/(roots[j]).setAttribute( \n                                    this.#refToArgs[i].attribute,\n                                    /**@type {string}*/(value)\n                              );\n                        }\n                  }else if(  this.#refToArgs[i].isRef ){\n                        // only the last root is used\n                        //@ts-ignore\n                        self.element = roots.at(-1);\n                  }else if(  this.#refToArgs[i].isTextNode ){\n\n                        for( let i = 0; i < roots.length; i++ ){\n                              roots[i].textContent = /**@type {string}*/(value)\n                        }\n                  }else if(  this.#refToArgs[i].isTagName ){\n                        for( let i = 0; i < roots.length; i++ ){\n\n                              const node = document.createElement( /**@type {string}*/(value) );\n                              const attrib = /**@type {HTMLElement}*/(roots[i]).attributes;\n                              \n                              for( let i = 0; i < attrib.length; i++ ){\n                                    node.setAttribute(\n                                          attrib[i][0],\n                                          attrib[i][1]\n                                    );\n                              }\n                        }\n                  }\n\n            }\n\n            return components;\n      }\n\n      /**\n       * update all the args that **are** components.\n       * @param {readonly number[]} components \n       */\n      #updateComponents( components ){\n            // update all the components\n            // is done backward because first we need to update\n            // possible children of other components\n            for( let i = components.length - 1; i >= 0 ; i-- ){\n                  const idx = components[i];\n                  const self = this.#args[idx];\n                  const desc = this.#refToArgs[idx];\n\n                  \n\n                  if( self instanceof Component ){\n                        desc.root.at(-1).after( \n                              ...self.render({\n                                    tree: desc.children.children,\n                                    args: this.#args.slice( idx + 1, desc.children.numOfInterpolations + 1 ),\n                                    refToArgs: [],\n                                    idx: 0,\n                              })\n                        );\n                  }else if( isComponentList( self ) ){\n                        const tree = [];\n\n                        for( let i = 0; i < self.length; i++ ){\n                              tree.push(...self[i].render({\n                                    tree: desc.children.children,\n                                    args: this.#args.slice( idx + 1, desc.children.numOfInterpolations + 1 ),\n                                    refToArgs: [],\n                                    idx: 0,\n                              }));\n                        }\n\n                        desc.root.at(-1).after( ...tree );\n\n                  }\n\n            }\n      }\n\n      /**\n       * @param {Children} children \n       * @return {HTMLElement[]}\n       */\n      render( children ){\n            if( this.#root && this.#root.length > 0 ){\n                  \n                  for( let i = 0; i < this.__mount.length; i++ ){\n                        this.__mount[i]()\n                  }\n\n                  return /**@type {HTMLElement[]}*/([...this.#root]);\n            }\n\n            try{\n                  \n                  const {\n                        idx: _,\n                        childList\n                  } = this.#createDOMRecursive( \n                        this.#tree, \n                        children, \n                        this.#args,\n                        0, \n                        this.#refToArgs, \n                        0 \n                  );\n\n                  this.#root = childList;\n      \n                  const tree = /**@type {HTMLElement[]}*/([...this.#root]);\n\n                  for( let i = 0; i < this.__mount.length; i++ ){\n                        this.__mount[i]()\n                  }\n                  \n                  return tree;\n            }catch(e){\n                  for( let i = 0; i < this.__error.length; i++ ){\n                        this.__error[i]( e ); \n                  }\n                  console.error( e );\n            }\n\n            return [];\n      }\n\n      /**\n       * for all(args) if arg[i] != old(arg[i]) => update\n       * if the arg is a component of the same type as the old one, require update, \n       * otherwise change component\n       * @param  {...unknown} args \n       */\n      update( ...args ){\n            try{\n                  /**\n                   * all the args (indices) that needs update\n                   * @type {readonly number[]}\n                   */\n                  const toUpdate = this.#updateInternalState( ...args );\n                  /**\n                   * it is used to update components after all the other args \n                   * (in backward). this is done for components-children update\n                   * @type {readonly number[]}\n                   */\n                  const components = this.#updateAttributes( toUpdate );\n                  this.#updateComponents( components );\n            }catch( e ){\n                  for( let i = 0; i < this.__error.length; i++ ){\n                        this.__error[i]( e );\n                  }\n                  console.log(e)\n            }     \n      }\n\n      /**\n       * dispose a component by unsubscribing all it's dependencies and\n       * by removing all the tree associated with it from the dom\n       */\n      dispose(){\n            let curr = this.#subs.head;\n\n            // unsubscribe from all the reactive bindings\n            while( curr ){\n                  curr.value();\n                  curr = curr.next;\n            }\n\n            // remove all the tree from the dom\n            for( let i = 0; i < this.#root.length; i++ ){\n                  this.#root[i].remove();\n            }\n\n            for( let i = 0; i < this.__dispose.length; i++ ){\n                  this.__dispose[i]();\n            }\n\n      }\n\n      /**\n       * @param {Component} other \n       */\n      isEqualTo( other ){\n\n            if( this.#tree == other.#tree ){\n                  return true;\n            }\n\n            return false;\n      }\n}", "import Signal from \"../reactivity/signal.js\";\nimport ComponentParser from \"./component-parser.js\";\nimport Component from \"./component.js\";\nimport Effect from \"../reactivity/effect.js\";\nconst is = {\n      /**\n       * check if object is an effect\n       * @param {unknown} value \n       * @returns {value is Effect}\n       */\n      Effect: value => value && value instanceof Effect,\n      /**\n       * check if object is an effect\n       * @param {unknown} value \n       * @returns {value is Signal}\n       */\n      Reactive: value => value && value instanceof Signal,\n      /**\n       * check if object is a Ref\n       * @param {unknown} value \n       * @returns {value is Ref<HTMLElement>}\n       */\n      Ref: value => value && typeof value == 'object' && '__isRef__' in value && value.__isRef__ && 'element' in value && !Boolean(value.element),\n      /**\n       * true if the leaf is `<Children/>`\n       * @param {Tree} leaf \n       * @param {unknown} arg \n       * @returns {boolean} \n       */\n      ChildrenLeaf: ( leaf, arg ) => Boolean( leaf.tagName == 'Children' || ( leaf.tagName == ComponentParser.pointerToReactive && typeof arg == 'string' && arg == 'Children' ) ),\n      /**\n       * \n       * @param {unknown} value \n       * @returns {value is Component}\n       */\n      Component: value => typeof value == 'object' && value instanceof Component,\n      /**\n       * check if object is a component list\n       * note, it only checks the first and the last elements, \n       * ### if the first and the last elements are a Component, **all** the list will be rendered as a component\n       * @param {unknown} value \n       * @returns {value is Component[]}\n       */\n      ComponentList: value => typeof value == 'object' && value instanceof Array && (value[0] instanceof Component || value.length <= 0),\n}\n\nexport default  is;", "import * as List from \"./list.js\";\nimport is from \"../template/typeguard.js\";\n/**@import Signal from \"./signal.js\";*/\n\n/**\n * @template T\n */\nexport default class Effect {\n\n      /**\n       * @type {T}\n       */\n      #state;\n      /**\n       * @type {number}\n       */\n      #refCounter = 0;\n      /**\n       * @readonly\n       * @type {() => T}\n       */\n      #callback;\n      /**\n       * list of subscriptions\n       * @type {ListRoot<ReactiveRef>}\n       */\n      #subs = {\n            head: null,\n      };\n      /**\n       * list of function used to unsubscribe from\n       * all the dependencies\n       * @type {ListRoot<() => void>}\n       */\n      #unsubscribe = {\n            head: null,\n      };\n\n      /**\n       * @readonly\n       * @type {Signal<unknown>[]}\n       */\n      #dependencies;\n\n      get state() {\n            return this.#state;\n      }\n\n      /**\n       * @param {() => T} callback \n       * @param  {...Signal<unknown>} deps \n       */\n      constructor( callback, ...deps ){\n\n            this.#dependencies = deps;\n            this.#state = callback();\n            this.#callback = callback;\n      }\n\n      #updateState(){\n            const state = this.#callback();\n\n            if( state && typeof state !== 'object' && this.#state == state ){\n                  return;\n            }\n\n\n            \n            // update the component\n            if( is.Component( this.#state ) ){\n                  if( is.Component( state ) && this.#state.isEqualTo( state ) ){\n                        this.#state.update( ...state.args );\n                  }else{      \n                        this.#state.dispose();\n                        this.#state = state;\n                  }\n            }else if( is.ComponentList( this.#state ) ){\n\n                  if( is.ComponentList( state ) ){\n\n                        const minLen = this.#state.length > state.length ? \n                              state.length : \n                              this.#state.length;\n\n                        for( let i = 0; i < minLen; i++ ){\n                              if( this.#state[i].isEqualTo( state[i] ) ){\n                                    this.#state[i].update( ...state[i].args );\n                              }else{\n                                    this.#state[i].dispose();\n                                    this.#state[i] = state[i];\n                              }\n                        }\n\n                        if( minLen == state.length ){\n                              for( let i = minLen; i < this.#state.length; i++ ){\n                                    this.#state[i].dispose();\n                              }  \n\n                              this.#state.splice( minLen, this.#state.length - minLen );\n                        }else{\n                              this.#state.push( ...state.slice( minLen ) );\n                        }\n\n\n                  }else{    \n                        for( let i = 0; i < this.#state.length; i++ ){\n                              this.#state[i].dispose();\n                        }  \n                        this.#state = state;\n                  }\n            }else{\n                  this.#state = state;\n            }\n      }\n      /**\n       * return the function used to unsubscribe the subscription\n       * @param {ReactiveRef} ref \n       */\n      subscribe( ref ){\n\n            if( this.#refCounter <= 0 ){\n                  for( let i = 0; i < this.#dependencies.length; i++ ){\n                        List.append(\n                              this.#unsubscribe,\n                              this.#dependencies[i].subscribeEffect( this )\n                        );\n                  }\n            }\n            \n            List.append(\n                  this.#subs,\n                  ref,\n            );\n\n            this.#refCounter++;\n\n            const ticket = this.#subs.head;\n\n            return () => {\n                  this.#refCounter--;\n\n                  List.remove(\n                        this.#subs,\n                        ticket\n                  );\n\n                  if( this.#refCounter <= 0 ){\n                        let curr = this.#unsubscribe.head;\n\n                        while( curr ){\n                              // unsubscribing from all the effects\n                              curr.value();\n                              curr = curr.next;\n                        }\n\n                        this.#unsubscribe.head = null;\n                  }\n            };\n      }\n\n      /**\n       * update will work as follows:\n       * there will be a variable called refCounter,\n       * that tracks the number of components linked to this effect.\n       * if the effect reaches 0 refCount, it unsubscribe from every signal associated with\n       * it. on update, it will call the callback associated with the method, then it will update\n       * all the components linked to it\n       */\n      update(){\n            \n            this.#updateState();\n\n            let curr = this.#subs.head;\n\n            while( curr ){\n                  if( curr.value.isComponent ){\n                        const desc = /**@type {ComponentRef}*/(curr.value);\n\n                        if( is.ComponentList( this.#state ) ){\n\n                              const tree = [];\n\n                              for( let i = 0; i < this.#state.length; i++ ){\n                                    tree.push( ...this.#state[i].render({ args: [], tree: [], refToArgs: [], idx: 0, }) );\n                              }\n\n                              desc.root.after(...tree);\n                        }else if( is.Component( this.#state ) ){\n\n                              desc.root.after(\n                                    ...this.#state.render({ args: [], tree: [], refToArgs: [], idx: 0, })\n                              );\n                        }\n                  }else{\n                        const desc = /**@type {SimpleRef}*/(curr.value);\n\n                        if( desc.attributeValue ){\n                              /**@type {HTMLElement}*/(desc.root).setAttribute( desc.attribute, /**@type {string}*/(this.#state) );\n                        }else if( desc.isTextNode ){\n                              /**@type {Text}*/(desc.root).textContent = /**@type {string}*/(this.#state);\n                        }else{\n                              const node = document.createElement( /**@type {string}*/(this.#state) );\n                              desc.root.replaceWith( node );\n                              desc.root = node;\n                        }\n                  }\n                  \n                  curr = curr.next;\n            }\n      }   \n}", "class CssParser {\n      static #keyId = Math.trunc( Math.random() * 5760 + Math.random() * 1254 + 4578 );\n      /**\n       * @type {HTMLStyleElement}\n       */\n      static #styleRoot;\n      /**\n       * note, this is \n       * a CSS class\n       * @readonly\n       */\n      static #key = '.--Component--Scope__Key__';\n      /**\n       * holds the key of the style.\n       * the style is the key of the hashmap\n       * @type {Map<string,ScopedCss>}\n       */\n      static #styleCache = new Map();\n\n      /**\n       * @readonly\n       * @type {string}\n       */\n      #css;\n      /**\n       * @type {string}\n       */\n      #styleKey;\n\n      /**\n       * \n       * @param {string} css \n       */\n      constructor(css){\n            this.#css = css.replace( /\\s+/ig, ' ' );\n      }\n\n      /**\n       * returns the next same-level selector. the index is the index of the last '}'\n       * @param {number} styleStart \n       * @param {string} cssString \n       */\n      #getNextSelectorIndex( styleStart, cssString ){\n            // skip the inside\n            let openBrackets = 1;\n            // the first character is '{'\n            let j = styleStart + 1;\n\n\n            while( openBrackets > 0 && j < cssString.length ){\n                  if( cssString[j] == '}' ){\n                        openBrackets--;\n                  }else if( cssString[j] == '{' ){\n                        openBrackets++;\n                  }\n                  j++;\n            }\n\n            return j;\n      }\n\n      /**\n       * \n       * @param {string} selectors \n       */\n      #scopeSelectors( selectors ) {\n\n            return selectors\n            .split( /([,&>|+~ <])(?!\\=)/ig )\n            .map( v =>{\n\n                  if( !v.length || (v.match(/([,&>|+~ <])/) && v.length == 1) )\n                        return v;\n\n\n                  if( v.indexOf('[') >= 0 || v.indexOf(':') >= 0 ){\n                        return v.replace(/[a-zA-Z0-9_-][\\[:]/, m => m[0] + this.#styleKey + m[1] );\n                  }\n\n                  return v + this.#styleKey;\n            }).reduce( (p,c) => p + c );\n      }     \n\n      /**\n       * \n       * @param {string} cssString \n       * @returns \n       */\n      #scope( cssString ){\n\n            let res = '';\n            let i = 0;\n\n            while( i < cssString.length ){\n\n                  const styleStart = cssString.indexOf( '{', i );\n\n                  if( i < 0 ){\n                        // no more styles to parse\n                        return res + cssString.slice( i );\n                  }\n\n                  // contains all the selectors that \n                  // we want to scope\n                  const sel = cssString.slice( i, styleStart );\n\n                  // fuck, is a media query\n                  // we need to parse it's inside :'(\n                  if( sel.indexOf('@media') >= 0 ){\n\n\n                        const next = this.#getNextSelectorIndex( styleStart, cssString );\n\n                        const scoped = this.#scope( \n                              cssString.slice( styleStart + 1, next )\n                        );\n\n                        res += sel + '{' + scoped;\n\n                        i = next + 1;\n                        continue;\n                  }else if( sel.indexOf('@keyframe') >= 0 ){\n                        const j = this.#getNextSelectorIndex( styleStart, cssString );\n\n                        // we want to include the last '}', \n                        // so we need to add 1 to j \n                        // (that is on the character '}')\n                        res += cssString.slice( i, j + 1 );\n                        i = j + 1;\n                        continue;\n                  }\n\n                  let next = this.#getNextSelectorIndex( styleStart, cssString );\n\n                  res += this.#scopeSelectors( sel ) + cssString.slice( styleStart, next + 1 );\n                  i = next + 1;\n            }\n\n            return res;\n      }\n\n      scope(){\n            if( CssParser.#styleCache.has( this.#css ) ){\n                  return CssParser.#styleCache.get( this.#css );\n            }\n            // first, we need to generate a new unique key\n            this.#styleKey = CssParser.#key + (CssParser.#keyId++);\n\n            const scoped = this.#scope( this.#css );\n\n            if( !CssParser.#styleRoot ){\n                  CssParser.#styleRoot = document.createElement( 'style' );\n                  CssParser.#styleRoot.type = 'text/css';\n                  document.head.appendChild( CssParser.#styleRoot );\n            }\n            CssParser.#styleRoot.append(scoped);\n\n            CssParser.#styleCache.set( this.#css, { \n                  __css__Key: this.#styleKey.replace('.', '')\n            });\n\n            return { \n                  __css__Key: this.#styleKey.replace('.', '')\n            };\n      }\n\n\n}\n\n/**\n * creates a new scoped css module and return a unique key\n * that can be inserted later as an attribute in the html. \n * All the tags that **follows** the tag with the key attribute get the scope.\\\n * the scoped css is made adding a class to all the css selectors.\n * the class used is `.--Component--Scope__Key__` followed by a unique, randomly generated number\n * @example \n * ```javascript\n * const key = css`\n *  p {\n *      background-color: #fff;\n *  }`\n * \n * html`\n *      <p>i'm not scoped</p>\n *      <p scope=${key}> // <= this is not scoped\n *            <p> i'm scoped !!!</p>\n *      </p>\n *      <p> i'm scoped too!</p>\n * `\n * ```\n * @param {TemplateStringsArray} strings \n * @param  {...unknown} args \n */\nexport const css = ( strings, ...args ) => {\n      let res = strings[0];\n\n      for( let i = 0; i < args.length; i++ ) {\n            res += args[i] + strings[i + 1];\n      }\n\n      return new CssParser( res ).scope();\n}", "import Effect from \"./reactivity/effect.js\";\nimport Signal from \"./reactivity/signal.js\";\nimport Component from \"./template/component.js\";\nexport { css } from \"./css/index.js\";\nexport { Signal, Component, Effect };\n/**\n * \n * @param {TemplateStringsArray} strings \n * @param  {...unknown} args \n */\nexport const html = ( strings, ...args ) => {\n      return new Component( strings, ...args );\n}\n\n/**\n * \n * @param {Component} component \n * @param {HTMLElement} root\n */\nexport const createRoot = ( component, root )=>{\n      root.append( ...component.render({ tree: [], args: [], refToArgs: [], idx: 0 }) );\n}\n\n\n/**\n * create a context that can be retrieved by calling \n * the function returned by the createContext hook.\n * @example\n * ```javascript\n * const useTheme = createContext({ theme: 'dark' });\n * // ... later in the code\n * \n * const theme = useTheme();\n * if( theme.theme == 'dark' ){\n *     console.log('is dark!!!');\n * }\n * ```\n * @template {{}} T\n * @param {T} ctx\n */\nexport const createContext = ctx => {\n      return () => {\n            return ctx;\n      }\n}\n\n\n/**\n * create a state variable. each time variable.value changes, \n * it triggers the reload of each component that uses it.\n * `Signal` is the most important class of the frameworks.\n * it enables fine-grained reactivity and dependency tracking.\n * > important note: at current state, `Signal` are shallow, \n * > so if you change an internal property or you call a modifier\n * > method the ui will not be updated.\n *  @example \n * ```js\n * const signal = $signal(0);\n * \n * html`\n *    ${signal}\n *    <button ＠click=${() => signal.value++} > ADD </button>\n * `\n * \n * ```\n * @template T\n * @param {T} value \n */\nexport const $signal = value => new Signal( value );\n\n/**\n * creates an `Effect`. Effects are computed properties, that are \n * calculated each time one of the the dependencies changes. Effect are\n * useful also for reactive conditional rendering.\n * ### all the properties of the `Effect` object should not be used directly.\n * @example \n * ```js\n * const signal = $signal(0);\n * const effect = $effect(() => signal.value + 10, signal)\n * \n * \n * html`\n *    <div>${signal} + 10 = ${effect}</div>\n * `\n * \n * ```\n * @template T\n * @param {() => T} value \n * @param {Signal<unknown>[]} states\n */\nexport const $effect = ( value, ...states ) => new Effect( value, ...states );\n\n/**\n * connect the callback to the specified signal, producing a non-computed side effect.\n * the returned value is the unsubscribe function, that can be used to detach the listener\n * from the subscription list. \n * * @example \n * ```js\n * const signal = $signal(0);\n * const unsubscribe = $watcher(() => console.log(signal.value), signal)\n * \n * signal.value += 2; // log: 2\n * signal.value += 2; // log: 4\n * unsubscribe();\n * signal.value += 2; // log: nothing\n * ```\n * @param {()=>void} callback \n * @param {Signal<unknown>} signal \n */\nexport const $watcher = ( callback, signal ) => signal.subscribeEffect( { update: callback } );\n/**\n * provides an hook to an element of the DOM.\\\n * note that you don't need to pass it as value of the attribute 'ref', any attribute is valid\n * @example\n * ```javascript\n * function Input(){\n *    const input = $ref();\n *    \n *    return html`\n *          <input \n *           type=\"text\"\n *           value=\"\"\n *           ref=${input}\n *           ＠change=\"${() => console.log(input.element.value)}\"\n *          />\n *    `\n * }\n * ```\n * @template {HTMLElement} T - the type of the element you wish to anchor with the `$ref`\n * @returns {Ref<T>}\n */\nexport const $ref = () => {\n      return {\n            element: undefined,\n            __isRef__: true,\n      };\n} \n\n/**\n * create a function that will return a component with the possibility\n * to associate lifecycle hooks. This function enables composition API\n * and more fine-grained lifecycle handling\n * @example\n * ```javascript\n * const Name = useLifecycle(({ onMount }) => {\n *      onMount(() => {\n *                console.log('executed with the other')\n *      })\n *      return ({ name }) =>{\n *          onMount(() => {\n *                console.log(name)\n *          });\n *           return html`<div>${name}</div>`\n *      }\n * })\n * ```\n * @template T\n * @param {(on: LifecycleHook) => ((args: T) => Component)} factory \n */\nexport const useLifecycle = factory => {\n      /**\n       * @type {Array<()=>void>}\n       */\n      const onMount = [];\n      /**\n       * @type {Array<()=>void>}\n       */\n      const onDispose = [];\n      /**\n       * @type {Array<(e: Error)=>void>}\n       */\n      const onError = [];\n\n      const componentFactory = factory({ \n            onMount: c => onMount.push(c),\n            onDispose: c => onDispose.push(c),\n            onError: c => onError.push(c),\n      });\n\n\n      /**\n       * @param {T} args\n       */\n      return args => {\n            const component = componentFactory( args );\n            component.__dispose = onDispose;\n            component.__mount = onMount;\n            component.__error = onError;\n            return component\n      }\n}\nexport const GApp = {\n      /**\n       * \n       * @param {(args: Record<string,unknown>) => Component} component \n       * @param {string} name \n       */\n      registerComponent( component, name ) {\n            if( !component.name && !name ){\n                  throw new Error('component can be registered because is anonymous. Probably is the result of an high-order function call. In this case, explicitly pass a name as argument of the \"registerComponent\"')\n            }\n\n            Component.__register.set(\n                  name? name : component.name,\n                  component\n            );\n            return this;\n      },\n      /**\n       * \n       * @param {Component} component \n       * @param {HTMLElement} root\n       */\n      createRoot( component, root ){\n            root.append( ...component.render({ tree: [], args: [], refToArgs: [], idx: 0 }) );\n            return this;\n      }\n}"],
  "mappings": "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",
  "names": ["_subs", "html", "res", "usedArgs", "self", "other", "j", "i", "_subs", "css", "next"]
}
